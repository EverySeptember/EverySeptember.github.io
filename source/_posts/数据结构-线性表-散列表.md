---
title: 数据结构-线性表-散列表
date: 2019-4-3 09:56:01
tags: [数据结构,散列表]
---


散列表的英文是Hash Table，即日常所说的哈希表或者Hash表。

散列表用的是数组按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。

散列表的键（Key）经过散列函数（Hash函数）计算得到散列值（Hash值）作为数组下标，形成散列表。

# 哈希冲突

解决哈希冲突两种方法

## 寻址法（open addressing）

出现一个哈希冲突，便重新寻找一个空闲位置将其插入。

### 线性探测

- 插入：从当前位置一次向后查找，若之后均没有则重新从头查找；
- 查找：过程类似于插入，先与下标为目标哈希值的元素对照，如果相同则返回，如果不同则依次向后查找，如果找到有空闲位置则说明不存在；
- 删除：不能简单讲位置置空，否则会影响查找算法，应将删除的位置标记为deleted，查找到该位置时不是退出而是继续向下探测

该方法插入的数据越多，发生冲突的可能性越大，空闲位置会越少，探测时间会越久。极限情况下会达到O(n)。

### 二次探测

与线性探测原理类似，其步进长度不是1，而是步长的平方。

### 双重散列

该方法是在遇到哈希冲突的时候再次进行哈希，多次哈希直到找到空闲的位置。

无论是上述那种方法，空闲位置不多的时候，哈希冲突的概率都会大大提高。为了尽可能保证散列表的操作效率，一般情况下会尽可能保证散列表中有一定比例的空闲槽位。使用**装载因子（load factor）**来表示空位的多少。

装载因子的计算公式：`装入表中的元素个数 / 散列表的长度`。

装在因子越大，说明空闲位置越少，冲突越多，性能会下降。

### 寻址法的优缺点

- 优点
  - 所有数据都存在数组中，可有效利用CPU缓存加快查询速度	
  - 序列化简单
- 缺点
  - 删除数据比较麻烦
  - 解决冲突代价更高，比链表法更浪费空间

### 适用场景

数据量较小、装载因子较小的时候适合适用寻址法。

## 链表法（chaining）

链表法每个数组元素都是一个桶，桶中放置一个链表，哈希值相同的元素插入到相应的链表上。

- 优点
  - 链表法对内存的使用率比寻址法更高
  - 对大装载因子的容忍度更高，开放寻址法只能适用于装载因子小于1的情况；链表法可以承受装载因子大于1的情况，其查询效率会有下降，但仍优于顺序查找
- 缺点
  - 链表需要存储指针，其内存消耗要更高（当存储对象远大于指针大小时可以忽略）

### 适用场景

链表法散列表比较适合存储大对象、大数据量，而且它更加灵活，支持更多优化策略。

# 设计散列函数

原则

- 设计不能太复杂，否则会影响性能
- 生成的值要尽可能随机并且均匀分布。

# 散列表扩容

装载因子过大时需要启动动态扩容，在对数组进行扩容的同时需要重新计算哈希值。

插入一个数据最好情况是O(1)，最坏情况需要扩容，是O(n)，均摊计算是O(1)。

在对元素进行删除后装载因子会减小，此时可以进行动态缩容。

## 避免低效扩容

在扩容时可以选择不进行“一次性扩容”，可在初始化后在每次新插入数据时再从旧数据中选择一条插入到新数组中，多次O(1)复杂度的扩容，可有效提高效率。

# Java的HashMap分析

- 初始大小：默认16，如果初始化时目标明确，可以手动修改，这样能减少扩容次数，提高效率。
- 装载因子：默认0.75，超过0.75便会扩容为原来的两倍。
- 哈希冲突：JDK1.8中引入了红黑树，在链表长度过长（默认8）时，便会将链表树化；在红黑树节点过小（默认为6）的时候，红黑树又将变回链表。

# 工业级的散列表

## 应具有的特性

- 支持快速的插入、查询、删除操作
- 内存占用合理，不能浪费过多的空间
- 性能稳定，极端情况下的性能也不能退化到无法接受的情况

## 设计原则

- 设计一个合适的散列函数
- 定义装载因子阈值，并且合理设计动态扩容策略
- 选择合适的解决哈希冲突的方法

# 散列表与链表结合使用

## LRU算法

![LRU算法](https://static001.geekbang.org/resource/image/ea/6e/eaefd5f4028cc7d4cfbb56b24ce8ae6e.jpg)

在散列表中使用双向链表作为存储介质，prev与next做双向链表寻址使用，hnext则将链表的节点添加到散列表中去，实现双向链表与散列表的结合。

- 查找数据：根据散列表进行复杂度为O(1)的寻找，找到之后将该数据移动到链表的尾部
- 删除数据：首先找到该数据位置，其后将该数据从散列表和链表上分别删除
- 添加数据：首先在散列表中寻找该数据，如果找不到则将该数据添加到链表的尾端；如果此时缓存已满，则需要将首端数据清除，然后再将数据添加到链表的尾部

## Redis有序集合

跳表与散列表的结合，在跳表节点中添加散列表的地址属性，使相同的节点指向的散列表节点总是相同的。

## Java LinkedHashMap

使用双向链表与散列表同时使用，原理与LRU缓存相同。