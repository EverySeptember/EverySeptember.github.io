<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>这里是lu</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="这里是lu">
<meta property="og:url" content="http://everyseptember.github.io/page/4/index.html">
<meta property="og:site_name" content="这里是lu">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="lu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="这里是lu" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">这里是lu</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://everyseptember.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-算法-排序" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/01/26/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/" class="article-date">
  <time class="dt-published" datetime="2019-01-26T07:44:54.000Z" itemprop="datePublished">2019-01-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/01/26/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/">算法-排序</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="冒泡、插入、选择"><a href="#冒泡、插入、选择" class="headerlink" title="冒泡、插入、选择"></a>冒泡、插入、选择</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h4 id="有序度"><a href="#有序度" class="headerlink" title="有序度"></a>有序度</h4><p>有序度是数组中具有有序关系的元素对的个数</p>
<h4 id="逆序度"><a href="#逆序度" class="headerlink" title="逆序度"></a>逆序度</h4><p>与有序度相反</p>
<h4 id="满有序度"><a href="#满有序度" class="headerlink" title="满有序度"></a>满有序度</h4><p>一个完全有序的数组中有序元素对的个数，计算方式为<code>n*(n-1)/2</code></p>
<p>逆序度 = 满有序度 - 有序度</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。</p>
<p>冒泡排序包含两个操作原子，比较和交换。每交换一次，有序度就加1。不管算法怎么改进，交换次数总是确定的，即为逆序度，也就是<code>n*(n-1)/2 – 初始有序度</code>。</p>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>最好情况下已经完全有序，则只需要经过一次冒泡，需要经过0次交换，即最好复杂度为<code>O(n)</code>；最坏情况下其初始有序度为0，即完全倒序，需要经过<code>n*(n-1)/2</code>次交换，则其复杂度为<code>O(n^2)</code>；其平均复杂度可以简单取中间值<code>n*(n-1)/4</code>次交换的情况，则其平均复杂度为<code>O(n^2)</code>。</p>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>冒泡排序仅涉及到相邻数据的交换，需要常量级的临时空间，其空间复杂度为<code>O(1)</code>，是原地排序算法。</p>
<h4 id="是否稳定"><a href="#是否稳定" class="headerlink" title="是否稳定"></a>是否稳定</h4><p>当相邻元素相等时，并不做交换操作，所以是稳定算法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] sort, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 外层循环确定需要排序的范围</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 标志位，判断有无数据交换</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 内层循环真正进行排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sort[j] &gt; sort[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = sort[j];</span><br><span class="line">                sort[j] = sort[j + <span class="number">1</span>];</span><br><span class="line">                sort[j + <span class="number">1</span>] = temp;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有发生数据交换，表示数据已经有序，提前退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        System.out.print(sort[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。</p>
<h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>最好情况下数组已经完全有序，<strong>从尾到头进行比对</strong>时，并不需要搬运数据，每次进入内层循环便会结束，所以其最好复杂度为<code>O(n)</code>；最坏情况下数组完全逆序，每一次比较都需要搬运数据，所以其时间复杂度为<code>O(n^2)</code>；一次插入操作的平均时间复杂度为<code>O(n)</code>（详见第二章），插入排序相当于执行了n次插入操作，则其平均时间复杂度为<code>O(n^2)</code>。</p>
<h4 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>插入排序不需要额外的空间，所以其空间复杂度为<code>O(1)</code>，是原地排序算法。</p>
<h4 id="是否稳定-1"><a href="#是否稳定-1" class="headerlink" title="是否稳定"></a>是否稳定</h4><p>从尾到头的插入算法，当新数据与目标位置相等时，不进行数据交换，所以是稳定算法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] sort, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 外层循环取未排序区间的第一个值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> value = sort[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录当前排序点的位置</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 内层循环将未排序的值与已排序值进行比较，并将其放入已排序区间</span></span><br><span class="line">        <span class="comment">// 采取从后向前排序，可以有效利用有效空间</span></span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sort[j] &gt; value) &#123;</span><br><span class="line">                <span class="comment">// 如果当前已排序数据大于目标数据，进行数据移动</span></span><br><span class="line">                sort[j + <span class="number">1</span>] = sort[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 当前位置小于目标值，结束查找，此时的j + 1即为排序点位置</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将值插入排序点位置</span></span><br><span class="line">        sort[j + <span class="number">1</span>] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        System.out.print(sort[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序的思路类似于插入排序，也分为已排序区和未排序区，但是选择排序每次会从未排序区中选择最小值与未排序区的第一个值进行交换，这样构成有序的已排序区。</p>
<h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>在最好情况下，即数组已经完全有序，选择排序算法仍然需要对未排序区的每一个数据进行比对，所以其最好时间复杂度为<code>O(n^2)</code>；最坏情况下，数组完全倒序，算法需要对每一个数据进行比对，所以其最坏时间复杂度为<code>O(n^2)</code>；简单计算，在其最好最坏时间复杂度均为<code>O(n^2)</code>的情况下，其平均时间复杂度为<code>O(n^2)</code>。</p>
<h4 id="空间复杂度-2"><a href="#空间复杂度-2" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>选择排序涉及到数据交换，需要常量级的临时空间，所以空间复杂度为<code>O(1)</code>，是原地排序算法。</p>
<h4 id="是否稳定-2"><a href="#是否稳定-2" class="headerlink" title="是否稳定"></a>是否稳定</h4><p>由于选择排序每次都会交换当前最小值与未排序区间第一个值的位置，所以是不稳定算法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] sort, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外层循环确定未排序区间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 记录未排序区间最小值的位置</span></span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="comment">// 内层循环找到未排序区间的最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// 当当前值大于已记录最小值，改变最小值的位置</span></span><br><span class="line">            <span class="keyword">if</span> (sort[min] &gt; sort[j]) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换最小值的位置</span></span><br><span class="line">        <span class="keyword">int</span> temp = sort[i];</span><br><span class="line">        sort[i] = sort[min];</span><br><span class="line">        sort[min] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        System.out.print(sort[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="归并、快排"><a href="#归并、快排" class="headerlink" title="归并、快排"></a>归并、快排</h1><p>归并排序和快速排序都用到了分治思想，这两种算法更适合大规模数据排序，其时间复杂度均为<code>O(nlogn)</code>。</p>
<p>分治算法一般都用递归实现。</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序把数组分成前后两部分，然后对前后两部分分别进行排序，再将排序好的两部分合并在一起。</p>
<h4 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>递归函数的时间复杂度可以分解为<code>T(a) = T(b) + T(c) + K</code>的形式，而归并合并函数时间复杂度为<code>O(n)</code>；所以，当对n个元素进行排序时，归并排序的时间复杂度为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// n = 1时，只需要常量级别的操作</span><br><span class="line">T(1) = C;</span><br><span class="line">T(n) = 2 * T(n / 2) + n;</span><br></pre></td></tr></table></figure>

<p>循坏迭代：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T(n) = 2 * T(n / 2) + n</span><br><span class="line">	 = 2 * (2 * T(n / 4) + n / 2) + n = 4 * T(n / 4) + 2 * n</span><br><span class="line">     = 4 * (2 * T(n / 8) + n / 4) + 2 * n = 8 * T(n / 8) + 3 * n</span><br><span class="line">     = ...</span><br><span class="line">     = 2^k * T(n / 2^k) + k * n</span><br></pre></td></tr></table></figure>

<p>当<code>n / 2^k = 1</code>时，即<code>T(n / 2^k) = T(1) = C</code>，有<code>k = log2 n</code>，最终得<code>T(n) = 2 ^ (log2 n) * C + n * (log2 n) = Cn + nlogn</code>，使用O标记法即为<code>O(nlogn)</code>。</p>
<p>归并排序的执行效率与原始数组有序度无关，则其最好、最坏、平均时间复杂度均为<code>O(nlogn)</code>。</p>
<h4 id="空间复杂度-3"><a href="#空间复杂度-3" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>归并排序合并时需要申请一个临时数组空间，而该空间在每次合并完成之后便会被释放，所以其空间占用只会在合并函数内，其空间复杂度最大为原始数组的长度n，即为其空间复杂度为<code>O(n)</code>，并不是原地排序算法。</p>
<h4 id="稳定"><a href="#稳定" class="headerlink" title="稳定"></a>稳定</h4><p>在合并排序函数中，判断语句<code>sort[i] &lt;= sort[j]</code>使用小于等于可以保证有两个值相同时，在第一个子数组中的数据优先排序，这样可保证了数据稳定性，所以归并排序可以是一个稳定算法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sort 原始数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p 当前子数组的起始位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> r 当前子数组的终止位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] sort, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 确定终止条件：当输入的起点位置大于等于终点位置，则终止排序</span></span><br><span class="line">    <span class="keyword">if</span> (p &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取分割点</span></span><br><span class="line">    <span class="keyword">int</span> q = (p + r) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对两半部分分别进行分割排序</span></span><br><span class="line">    mergeSort(sort, p, q);</span><br><span class="line">    mergeSort(sort, q + <span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">// 对两半部分进行合并排序</span></span><br><span class="line">    merge(sort, p, q, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序的合并排序函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sort 原始数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p 第一个子数组的起始位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> q 第一个子数组的终止位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> r 第二个子数组的终止位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] sort, <span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = p, j = q + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 申请一个与合并后数组大小相同的临时数组</span></span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[r - p + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 进行数据比较，将sort前后两部分中较小的值按照顺序放到临时数组中</span></span><br><span class="line">    <span class="comment">// 当一个子数组排序完成，便会退出当前比较，需要将另一个子数组继续排序</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= q &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sort[i] &lt;= sort[j]) &#123;</span><br><span class="line">            temp[k++] = sort[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = sort[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断并未完全进行排序的子数组</span></span><br><span class="line">    <span class="keyword">int</span> start = i, end = q;</span><br><span class="line">    <span class="keyword">if</span> (j &lt;= r) &#123;</span><br><span class="line">        start = j;</span><br><span class="line">        end = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将剩余的数据放到临时数组</span></span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">        temp[k++] = sort[start++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将临时数组中的数据放回原数组中的目标位置</span></span><br><span class="line">    <span class="comment">// 原数组会被污染，但目标位置已经不会再被用到，所以并不影响</span></span><br><span class="line">    <span class="comment">// 原始数组要从第一个子数组的起始位置开始替换</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; temp.length; l++) &#123;</span><br><span class="line">        sort[p + l] = temp[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// java自带的数组合并方法，这种方式更简单，使用fori的方式有助于理解</span></span><br><span class="line">    <span class="comment">// System.arraycopy(temp, 0, sort, p, temp.length);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>如果要在对数组中下标从p到r的一个组数据排序，则任意选择p到r之间的一个数据作为q（分区点）。</p>
<p>遍历数组中p到r之间的数据，将小于q的数据放到q左边，反之放到右边。</p>
<p>之后利用分治和递归的处理思想，分别处理p到q-1和q+1到r的数据，直到区间缩小为1，该数组便完全有序了。</p>
<h4 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>快排的平均时间复杂度计算方式与归并相同，为<code>O(nlogn)</code>；而在分区点选取不合理的情况下，比如极端情况下，数组已经有序，分区点从末位开始选择，则每次递归都会有一个递归公式结束，另一个递归公式变成<code>n-1</code>的排序的情况，这时相当于使用了n次递归，每次递归进行了一个时间复杂度为<code>O(n)</code>的排序，其复杂度变成了<code>O(n^2)</code>。</p>
<p>快排可以选择不同的分区点选择方法来优化时间复杂度。</p>
<h5 id="分区选择方法"><a href="#分区选择方法" class="headerlink" title="分区选择方法"></a>分区选择方法</h5><ul>
<li><p>三数取中法</p>
<p>可以从区间的首、尾、中间分别取一个数，取其中间值作为分区点；如果数组较大，则可取更多的数字取中。</p>
</li>
<li><p>随机法</p>
<p>从概率学来讲，不能保证每次都获得最好选择，但可以避免每次都出现很差的情况，这样的分区点也是好的。</p>
</li>
</ul>
<h4 id="空间复杂度-4"><a href="#空间复杂度-4" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>合理设计原地分区函数可以不使用循环以外的临时空间，所以其空间复杂度为<code>o(1)</code>，是原地排序算法。</p>
<h4 id="稳定-1"><a href="#稳定-1" class="headerlink" title="稳定"></a>稳定</h4><p>在比较数组中有与分区点数组相同的数据时，二者的顺序会被交换，所以不是稳定算法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sort 原始数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p 当前子数组起点位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> r 当前子数组终点位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] sort, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取分区点</span></span><br><span class="line">    <span class="keyword">int</span> q = partition(sort, p, r);</span><br><span class="line">    <span class="comment">// 递归排序</span></span><br><span class="line">    quickSort(sort, p, q - <span class="number">1</span>);</span><br><span class="line">    quickSort(sort, q + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原地分区函数</span></span><br><span class="line"><span class="comment"> * 该函数的思想类似于选择排序，使用一个移动点将数组分割成两个区域</span></span><br><span class="line"><span class="comment"> * 遍历数组与分区点的数据对比，小于分区点数据的放到前区，同时将前区扩大一位</span></span><br><span class="line"><span class="comment"> * 循环结束时，将分区点数据与当前分割点数据交换位置</span></span><br><span class="line"><span class="comment"> * 最后返回当前移动点位置作为新的分区点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sort 原始数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p 当前子数组起点位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> r 当前子数组终点位置，同时作为分区点使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 分区点位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] sort, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = sort[r];</span><br><span class="line">    <span class="comment">// 定义变量i，将数组划分成两个区域</span></span><br><span class="line">    <span class="keyword">int</span> i = p;</span><br><span class="line">    <span class="comment">// 循环遍历从p到r - 1的数组，查找比value小的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = p; j &lt; r; j++) &#123;</span><br><span class="line">        <span class="comment">// 若当前遍历位置数据小于value，则</span></span><br><span class="line">        <span class="comment">// ①将其与分区点位置数据互换</span></span><br><span class="line">        <span class="comment">// ②同时将当前的分区点位置后移一位</span></span><br><span class="line">        <span class="keyword">if</span> (sort[j] &lt; value) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = sort[j];</span><br><span class="line">            sort[j] = sort[i];</span><br><span class="line">            sort[i] = temp;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort[r] = sort[i];</span><br><span class="line">    sort[i] = value;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="桶、计数、基数（线性排序）"><a href="#桶、计数、基数（线性排序）" class="headerlink" title="桶、计数、基数（线性排序）"></a>桶、计数、基数（线性排序）</h1><p>这三种算法的时间复杂度都是<code>O(n)</code>，是非基于比较的排序算法，都不设计元素之间的比较操作。</p>
<p>线性排序算法条件要求十分苛刻，所以学习重点是掌握其使用条件。</p>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>排序，顾名思义，会用到“桶”，核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p>
<p>桶排序适用于数据分布均匀的数组，否则桶之间的大小差距会使时间复杂度急速上升。</p>
<h4 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>如果我们有n个数据，将他们均匀划分到m个桶中，则每个桶中会有<code>k = n / m</code>个元素，此时对每个桶中的数据进行快速排序，每个桶中的时间复杂度就是<code>O(klogk)</code>，m个桶的时间复杂度为<code>O(m * klogk)</code>，又因为<code>k = n / m</code>，所以桶排序的时间复杂度为<code>O(nlog(n/m))</code>；当n与m相近时，log(n/m)便是一个非常小的常数，此时时间复杂度接近<code>O(n)</code>。在数据分布极度不均匀的情况（比如绝大多数数据分布在一个桶内）下，时间复杂度会退化成<code>O(n^2)</code>。</p>
<h4 id="空间复杂度-5"><a href="#空间复杂度-5" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>桶排序需要占用临时空间，其空间复杂度为<code>O(n)</code>，不是一个原地排序算法。</p>
<h4 id="稳定-2"><a href="#稳定-2" class="headerlink" title="稳定"></a>稳定</h4><p>桶排序并不涉及数据之间的比较，势必会打破数据稳定性，是一个不稳定算法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桶排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sort 排序数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span>[] sort)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义每个桶的容量，实际应用可实际判断</span></span><br><span class="line">    <span class="keyword">int</span> capacity = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 寻找最大最小值</span></span><br><span class="line">    <span class="keyword">int</span> max = sort[<span class="number">0</span>], min = sort[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sort.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (min &gt; sort[i]) &#123;</span><br><span class="line">            min = sort[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max &lt; sort[i]) &#123;</span><br><span class="line">            max = sort[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算同编号起始终止位置</span></span><br><span class="line">    <span class="keyword">int</span> start = min / capacity;</span><br><span class="line">    <span class="keyword">int</span> end = max / capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个桶链</span></span><br><span class="line">    <span class="comment">// Integer指桶的序号，ArrayList指桶</span></span><br><span class="line">    Map&lt;Integer, ArrayList&lt;Integer&gt;&gt; buckets = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次将数据压入桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sort.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 计算当前数据属于哪个桶</span></span><br><span class="line">        <span class="keyword">int</span> index = sort[i] / capacity;</span><br><span class="line">        <span class="comment">// 判断当前桶是否存在，不存在则创建</span></span><br><span class="line">        <span class="keyword">if</span> (buckets.get(index) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建桶</span></span><br><span class="line">            buckets.put(index, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 压入桶中</span></span><br><span class="line">        buckets.get(index).add(sort[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经排序的长度</span></span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将桶按照序号大小循环排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="comment">// 使用快排对桶内数据进行排序</span></span><br><span class="line">        ArrayList&lt;Integer&gt; bucket = buckets.get(i);</span><br><span class="line">        <span class="comment">// 跳过空桶</span></span><br><span class="line">        <span class="keyword">if</span> (bucket == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Integer[] a = bucket.toArray(<span class="keyword">new</span> Integer[bucket.size()]);</span><br><span class="line">        quickSortInteger(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 将桶内数据放回数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">            sort[p + j] = a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        p += a.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有整数且无重复数据的极简版本，此法运用范围有限</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] simpleBucketSort(<span class="keyword">int</span>[] sort) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找最大最小值</span></span><br><span class="line">    <span class="keyword">int</span> max = sort[<span class="number">0</span>], min = sort[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sort.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (min &gt; sort[i]) &#123;</span><br><span class="line">            min = sort[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max &lt; sort[i]) &#123;</span><br><span class="line">            max = sort[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义桶的数量</span></span><br><span class="line">    <span class="keyword">int</span>[] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[max - min +<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 循环数据，每一个数据的值即其桶的序号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sort.length; i++) &#123;</span><br><span class="line">        buckets[sort[i]] = sort[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回的桶中包含大量0，跳过0既是有序数据</span></span><br><span class="line">    <span class="keyword">return</span> buckets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序类似于桶排序。</p>
<p>计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</p>
<h4 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>计数排序不涉及到桶内元素排序，每次都是<code>O(n)</code>的元素操作，所以其时间复杂度为<code>O(n)</code>。</p>
<h4 id="空间复杂度-6"><a href="#空间复杂度-6" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>计数排序需要占用临时空间，其空间复杂度为<code>O(n)</code>，不是一个原地排序算法。</p>
<h4 id="稳定-3"><a href="#稳定-3" class="headerlink" title="稳定"></a>稳定</h4><p>计数排序并不涉及数据之间的比较，势必会打破数据稳定性，是一个不稳定算法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计数排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sort 待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 数组长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] sort, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 寻找最大最小值</span></span><br><span class="line">    <span class="keyword">int</span> max = sort[<span class="number">0</span>], min = sort[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (min &gt; sort[i]) &#123;</span><br><span class="line">            min = sort[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max &lt; sort[i]) &#123;</span><br><span class="line">            max = sort[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算偏移量</span></span><br><span class="line">    <span class="keyword">int</span> offset = <span class="number">0</span> - min;</span><br><span class="line">    <span class="comment">// 以 排序数字 + 偏移量 为桶号创建桶群</span></span><br><span class="line">    <span class="keyword">int</span>[] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[max + offset + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 当前排序数字+偏移量 为桶号的桶内元素加一</span></span><br><span class="line">        buckets[sort[i] + offset]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 桶群内元素数量依次累加，使桶内值为前桶的累加和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        buckets[i] += buckets[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建返回数组</span></span><br><span class="line">    <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="comment">// 计数排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 对原数组每一个元素按照桶群中的顺序放到返回数组中</span></span><br><span class="line">        a[buckets[sort[i] + offset]-- - <span class="number">1</span>] = sort[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数组拷贝</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        sort[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序实现原理也类似于桶排序。将数据按照位数分割，每一个位数上的数值放到相应的桶号上，然后按照桶号依次将桶内数据放回到待排序数组中。依次进行，直至循环所有数据的所有位数。</p>
<h4 id="时间复杂度-7"><a href="#时间复杂度-7" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>基数排序时间复杂度为<code>O(k * n)</code>，k为待排序数组中最大位数，一般情况下其时间复杂度为<code>O(n)</code>，随k增大，在极端情况下有可能会退化为<code>O(nlogn)</code>甚至<code>O(n^2)</code>。</p>
<h4 id="空间复杂度-7"><a href="#空间复杂度-7" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>基数排序需要<code>O(n)</code>的额外空间。</p>
<h4 id="稳定-4"><a href="#稳定-4" class="headerlink" title="稳定"></a>稳定</h4><p>基数排序中需要保证已排序位数不会被后续排序破坏顺序，所以是稳定排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基数排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sort</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] sort)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = sort.length;</span><br><span class="line">    <span class="comment">// 寻找最大最小值</span></span><br><span class="line">    <span class="keyword">int</span> max = sort[<span class="number">0</span>], min = sort[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (max &lt;  sort[i]) &#123;</span><br><span class="line">            max = sort[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (min &gt; sort[i]) &#123;</span><br><span class="line">            min = sort[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算最大位数</span></span><br><span class="line">    <span class="keyword">int</span> maxLen = String.valueOf(max - min).length();</span><br><span class="line">    <span class="comment">// 创建桶群</span></span><br><span class="line">    <span class="comment">// 桶群第一维表示桶号</span></span><br><span class="line">    <span class="comment">// 桶群第二维表示桶内是放置待排序数字组成的的数组</span></span><br><span class="line">    <span class="keyword">int</span>[][] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][n];</span><br><span class="line">    <span class="comment">// 创建当前桶的计数数组，保证每个桶中的数字都是从0开始累加</span></span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// 计算偏移值</span></span><br><span class="line">    <span class="keyword">int</span> offset = <span class="number">0</span> - min;</span><br><span class="line">    <span class="comment">// 按照位数循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxLen; i++) &#123;</span><br><span class="line">        <span class="comment">// 定义原数组中已经排序的元素个数</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 将数字依次放入桶中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// 计算当前位的余数</span></span><br><span class="line">            <span class="keyword">int</span> lsd = ((sort[j] + offset) / (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, i)) % <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 表示桶号为lsd的桶中放置一个元素，同时对应的计数数组加一</span></span><br><span class="line">            buckets[lsd][count[lsd]++] = sort[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将桶中的数字依次取出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// 计数数组等于零，则进入下一循环</span></span><br><span class="line">            <span class="keyword">if</span> (count[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; count[j]; k++) &#123;</span><br><span class="line">                sort[l++] = buckets[j][k];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计数数组清零</span></span><br><span class="line">            count[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://everyseptember.github.io/2019/01/26/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/" data-id="ckp7osn73005p0es58fgo1d7d" data-title="算法-排序" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Springboot实战笔记6" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/01/26/Springboot%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B06/" class="article-date">
  <time class="dt-published" datetime="2019-01-26T01:26:29.000Z" itemprop="datePublished">2019-01-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/01/26/Springboot%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B06/">Springboot实战笔记6</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="部署、打包与发布"><a href="#部署、打包与发布" class="headerlink" title="部署、打包与发布"></a>部署、打包与发布</h2><h3 id="热部署（IDEA）"><a href="#热部署（IDEA）" class="headerlink" title="热部署（IDEA）"></a>热部署（IDEA）</h3><ul>
<li><p>热部署前提必须是debug启动</p>
</li>
<li><p>关闭Thymeleaf缓存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.thymeleaf.cache=false</span><br></pre></td></tr></table></figure></li>
<li><p>在pom.xml中定义devtools，且在maven插件中添加配置类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;/dependencies&gt;</span><br><span class="line">	&lt;!-- 官方提供的热部署工具，用以监控class文件是否发生变化 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;!-- 增加fork才允许热部署，允许多个类加载器 --&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;fork&gt;true&lt;/fork&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>IDEA中的设置</p>
<ol>
<li>需要打开<code>File | Settings | Build, Execution, Deployment | Compiler</code>中的<code>Build project automatically</code></li>
<li>打开<code>Ctrl shift a</code>，找到registry，保证<code>compiler.automake.allow.when.app.running</code>打开</li>
</ol>
</li>
</ul>
<h5 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h5><ul>
<li>本方法实测只有在idea失去焦点的时候才会部署，且部署仍是重启程序，启动较慢，以后有大项目之后再观察</li>
</ul>
<h3 id="Jar包与发布"><a href="#Jar包与发布" class="headerlink" title="Jar包与发布"></a>Jar包与发布</h3><p>首先，在pom.xml中将项目描述为<code>&lt;packaging&gt;jar&lt;/packaging&gt;</code></p>
<h5 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h5><ul>
<li><p>IDEA使用maven命令的方式</p>
<ol>
<li><p>在发布方式中新增maven，命令为package</p>
<p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1fzjrnk4qw7j31fu0u04ij.jpg" alt="新增打包命令"></p>
</li>
<li><p>运行该启动方式，生成jar包</p>
</li>
<li><p>将application.properties放到jar包同一目录下可以直接修改项目参数</p>
</li>
</ol>
</li>
<li><p>直接使用maven插件的方式</p>
<p><img src="https://ws3.sinaimg.cn/large/005BYqpgly1fzjsfvjsvoj312a0kokcy.jpg" alt="maven插件的方式"></p>
</li>
</ul>
<h5 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h5><ul>
<li>Linux下后台运行<ul>
<li>输入命令<code>nohup java -jar deploy-0.0.1-SNAPSHOT.jar &gt;&gt; out.log &amp;</code></li>
<li>nohup表示静默输出，<code>&gt;&gt;</code>将信息输出到指定目标文件，<code>&amp;</code>符号不可少</li>
<li>停止项目：直接kill</li>
</ul>
</li>
</ul>
<h3 id="War包与发布"><a href="#War包与发布" class="headerlink" title="War包与发布"></a>War包与发布</h3><p>首先，在pom.xml中将项目描述为<code>&lt;packaging&gt;war&lt;/packaging&gt;</code></p>
<h5 id="打包-1"><a href="#打包-1" class="headerlink" title="打包"></a>打包</h5><ol>
<li><p>添加依赖，<code>&lt;scope&gt;provided&lt;/scope&gt;</code>目的是仅在编译时使用该jar包，打包和运行时，不使用该jar</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>其他scope范围<ul>
<li>runtime，默认值，在编译、运行、发布时均存在</li>
<li>runtime，运行时，本地编译时不用该jar包，运行发布时加载到运行环境中</li>
</ul>
</li>
</ul>
</li>
<li><p>将原有入口类main方法失效</p>
<ol>
<li><p>入口类继承<code>SpringBootServletInitializer</code>类，该类的作用就是在tomcat启动的时候，执行内置的configure方法，将其托管给Spring Boot；同时重写configure方法，指定托管的入口类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class DeployApplication extends SpringBootServletInitializer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123;</span><br><span class="line">        return builder.sources(DeployApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(DeployApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>IDEA使用maven的打包配置方式与jar完全相同，可直接使用已经配置好的命令</p>
</li>
<li><p>运行该命令</p>
</li>
</ol>
</li>
</ol>
<h5 id="发布-1"><a href="#发布-1" class="headerlink" title="发布"></a>发布</h5><ol>
<li>将war包放到tomcat webapps目录下</li>
<li>启动过程中el包可能与tomcat自带el包产生冲突，可将tomcat自带该包删除</li>
<li>启动Tomcat</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://everyseptember.github.io/2019/01/26/Springboot%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B06/" data-id="ckp7osn4u000o0es5cx390w0n" data-title="Springboot实战笔记6" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Springboot%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B0/" rel="tag">Springboot零散笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Springboot实战笔记5" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/01/24/Springboot%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B05/" class="article-date">
  <time class="dt-published" datetime="2019-01-24T11:43:48.000Z" itemprop="datePublished">2019-01-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/01/24/Springboot%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B05/">Springboot实战笔记5</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><p>MyBatis是一款优秀的持久层框架，它支持定制化SQL、存储过程以及高级映射。MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。MyBatis可以使用简单的XML或者注解来映射原生信息，将接口的POJOs（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录。</p>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol>
<li><p>引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>配置application.properties</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mybatis.config-location=classpath:/mybatis/mybatis-config.xml</span><br><span class="line">mybatis.mapper-locations=classpath:/mybatis/mapper/*.xml</span><br></pre></td></tr></table></figure></li>
<li><p>配置mybatis-config.xml</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">	...</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>开发应用</p>
<ol>
<li><p>创建mapper包，在包中添加相应实体的mapper接口类</p>
</li>
<li><p>在<code>/mybatis/mapper/</code>路径配置相应于接口的xml配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;!--映射文件配置，namespace指向接口--&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.lu.springbootmybatis.mapper.EmpMapper&quot;&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>在service中注入mapper接口类，直接使用方法</p>
</li>
<li><p>在SpringBoot入口类中添加<code>@MapperScan(&quot;com.lu.springbootmybatis.mapper&quot;)</code>注解，指向mapper接口类的路径，使其在项目启动时被加载，从而项目启动时MyBatis会实现接口类中的方法</p>
</li>
</ol>
</li>
</ol>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><p>xml文件配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;!--映射文件配置，namespace指向接口--&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.lu.springbootmybatis.mapper.EmpMapper&quot;&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">        select 表示查询，</span><br><span class="line">        id要与接口中的方法名对应上，</span><br><span class="line">        parameterType是该方法参数类型，</span><br><span class="line">        resultType指定返回值类型，以完成自动注入</span><br><span class="line">        #&#123;value&#125;即为参数值</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;select id=&quot;findById&quot; parameterType=&quot;Integer&quot; resultType=&quot;com.lu.springbootmybatis.entity.Emp&quot;&gt;</span><br><span class="line">        select * from emp where empno = #&#123;value&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>在xml文件中定义<code>resultType=&quot;java.util.Map&quot;</code>可以有效扩展多表返回值</p>
</li>
<li><p><code>parameterType=&quot;java.util.Map&quot;</code>可以传多个参数到SQL语句中，直接使用<code>#&#123;key&#125;</code>便可以自动对应，key表示参数map的key</p>
</li>
<li><p>MyBatis默认不输出SQL到日期，对mapper包调整日志输出等级便可打印SQL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.level.com.lu.springbootmybatis.mapper=debug</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="动态查询"><a href="#动态查询" class="headerlink" title="动态查询"></a>动态查询</h5><p>使用<code>&lt;if test=&quot;&quot;&gt;&lt;/if&gt;</code>标签</p>
<h3 id="创建数据"><a href="#创建数据" class="headerlink" title="创建数据"></a>创建数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insert&quot; parameterType=&quot;com.lu.springbootmybatis.entity.Emp&quot;&gt;</span><br><span class="line">    INSERT INTO `scott`.`emp`(`ename`, `job`, `mgr`, `hiredate`, `sal`, `comm`, `deptno`)</span><br><span class="line">    VALUES (#&#123;ename&#125;, #&#123;job&#125;, #&#123;mgr&#125;, #&#123;hiredate&#125;, #&#123;sal&#125;, #&#123;comm&#125;, #&#123;deptno&#125;)</span><br><span class="line">    &lt;selectKey keyProperty=&quot;empno&quot; keyColumn=&quot;empno&quot; resultType=&quot;Integer&quot; order=&quot;AFTER&quot;&gt;</span><br><span class="line">        select LAST_INSERT_ID()</span><br><span class="line">    &lt;/selectKey&gt;</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用insert标签，标签内部直接写SQL</p>
</li>
<li><p>Mapper方法中参数必须是对应的实体类，SQL占位符名称用实体类属性名</p>
</li>
<li><p>在insert标签中添加<code>&lt;selectKey&gt;&lt;/selectKey&gt;</code>获取最新插入的ID，order=”AFTER”表示插入数据之后查询ID，select LAST_INSERT_ID()是mysql的查询方法</p>
</li>
</ul>
<h3 id="删改"><a href="#删改" class="headerlink" title="删改"></a>删改</h3><p>分别使用update和delete标签即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id=&quot;update&quot; parameterType=&quot;com.lu.springbootmybatis.entity.Emp&quot;&gt;</span><br><span class="line">    update `scott`.`emp` set `ename` = #&#123;ename&#125;, `job` = #&#123;job&#125;, `mgr` = #&#123;mgr&#125;,</span><br><span class="line">    `hiredate` = #&#123;hiredate&#125;, `sal` = #&#123;sal&#125;, `comm` = #&#123;comm&#125;, `deptno` = #&#123;deptno&#125;</span><br><span class="line">    where `empno` = #&#123;empno&#125;</span><br><span class="line">&lt;/update&gt;</span><br><span class="line"></span><br><span class="line">&lt;delete id=&quot;delete&quot; parameterType=&quot;Integer&quot;&gt;</span><br><span class="line">    delete from emp where empno = #&#123;empno&#125;</span><br><span class="line">&lt;/delete&gt;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://everyseptember.github.io/2019/01/24/Springboot%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B05/" data-id="ckp7osn4s000m0es561h07605" data-title="Springboot实战笔记5" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Springboot%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B0/" rel="tag">Springboot零散笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Springboot实战笔记4" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/01/24/Springboot%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B04/" class="article-date">
  <time class="dt-published" datetime="2019-01-24T11:41:09.000Z" itemprop="datePublished">2019-01-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/01/24/Springboot%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B04/">Springboot实战笔记4</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Spring-Data与JPA"><a href="#Spring-Data与JPA" class="headerlink" title="Spring Data与JPA"></a>Spring Data与JPA</h2><p>Spring Data项目的目的是简化构建基于Spring框架应用的数据访问技术，包括关系型数据库、非关系型数据库、Map-Reduce框架、云数据服务等；</p>
<p>JPA是Java Persistence API的简称，中文名是Java持久层API，是JDK 5.0注解或XML描述对象-关系表的映射关系，并将运行期的实体对象持久化到数据库中。</p>
<p>SpringData JPA是SpringData下的一个重要模块，负责关系型数据库的映射；实现了Java JPA标准。</p>
<p>SpringData默认的JPA实现是Hibernate。</p>
<h5 id="Hibernate优缺点"><a href="#Hibernate优缺点" class="headerlink" title="Hibernate优缺点"></a>Hibernate优缺点</h5><ul>
<li>优点<ul>
<li>面向对象</li>
<li>更好的移植性</li>
<li>开发效率高</li>
</ul>
</li>
<li>缺点<ul>
<li>运行效率慢</li>
<li>结构臃肿</li>
<li>JPQL/HQL存在硬伤</li>
</ul>
</li>
<li>使用建议<ul>
<li>用户量不大，或许要敏捷开发的企业级应用</li>
<li>互联网项目慎用</li>
</ul>
</li>
</ul>
<h3 id="基本操作CRUD"><a href="#基本操作CRUD" class="headerlink" title="基本操作CRUD"></a>基本操作CRUD</h3><ol>
<li><h5 id="在application-properties配置数据库连接配置"><a href="#在application-properties配置数据库连接配置" class="headerlink" title="在application.properties配置数据库连接配置"></a>在application.properties配置数据库连接配置</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/scott?useUnicode=true&amp;characterEncoding=utf-8</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br><span class="line"># show-sql可以在运行时展示sql语句</span><br><span class="line">spring.jpa.show-sql=true</span><br></pre></td></tr></table></figure></li>
<li><h5 id="创建实体类"><a href="#创建实体类" class="headerlink" title="创建实体类"></a>创建实体类</h5><ul>
<li>实体类使用<code>@Entity</code>和<code>@Table(name=&quot;&quot;)</code>注解，<code>@Entity</code>是实体类标识；SpringBoot启动时会加载这个类，<code>@Table</code>注解使表与表明一一对应</li>
<li>字段使用<code>@Column(name=&quot;&quot;)</code>注解，如果属性名与字段名相同则可以省略</li>
<li>在属性上添加<code>@Id</code>注解表示主键，使用<code>@GeneratedValue</code>表示序列增长模式<ul>
<li><code>@GeneratedValue(strategy = GenerationType.IDENTITY)</code>使用数据库自增</li>
<li><code>@GeneratedValue(strategy = GenerationType.SEQUENCE)</code>使用序列增长</li>
</ul>
</li>
</ul>
</li>
<li><p>创建Repository接口（类似于dao层接口）</p>
<ul>
<li>Repository接口继承org.springframework.data.jpa.repository.JpaRepository，则自动提供增删改查方法</li>
<li>JpaRepository传入泛型为需要关联的实体以及该实体主键的数据类型</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import com.lu.springdatajpa.entity.Dept;</span><br><span class="line">import org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"></span><br><span class="line">public interface DeptRepository extends JpaRepository&lt;Dept, Integer&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建Controller（以查询为例）</p>
<ul>
<li><p>在controller中注入Repository接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Resource</span><br><span class="line">private DeptRepository deptRepository = null;</span><br></pre></td></tr></table></figure></li>
<li><p>Repository接口查询返回值为<code>Optional&lt;T&gt;</code>，是实体类的包装类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Dept&gt; op = deptRepository.findById(id);</span><br><span class="line">Dept dept = null;</span><br><span class="line">// op.isPresent()判断是否对象存在</span><br><span class="line">if (op.isPresent()) &#123;</span><br><span class="line">	// op.get()方法可以直接获得实体类对象</span><br><span class="line">    dept = op.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Repository的创建和保存方法都是<code>save(T)</code>，根据是否拥有主键判断，如果有则新建，否则更新</p>
</li>
<li><p>删除方法为<code>delete(T)</code>，同时返回主键值</p>
</li>
<li><p>方法中可以使用<code>/&#123;参数名&#125;</code>注解来直接传值，在参数栏内使用<code>@PathVariable</code>直接引用，而前台不用输入参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">public T findById(@PathVariable(&quot;id&quot;) Integer id)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="自定义查询"><a href="#自定义查询" class="headerlink" title="自定义查询"></a>自定义查询</h3><p>SpringData JPA支持自定义查询方法，在Repository接口中按照规则命名抽象方法，不用提供实现。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sbin456/article/details/53304148">spring data jpa方法命名规则</a></p>
<p>一般情况下不推荐使用，因为复杂查询使得命名方法过于复杂。</p>
<h4 id="JPQL"><a href="#JPQL" class="headerlink" title="JPQL"></a>JPQL</h4><p>一种类SQL，在Repository接口中定义抽象方法，无命名规则，且使用<code>@Query</code>进行注解。</p>
<p>使用<code>:命名参数</code>进行传值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Query(&quot;select d from Dept d where d.dname = :dname&quot;)</span><br><span class="line">public List&lt;Dept&gt; findByDname(String dname);</span><br></pre></td></tr></table></figure>

<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li>大多数情况下将*替换为别名或直接使用表名</li>
<li>表名改为实体类名</li>
<li>字段名改为属性名</li>
</ul>
<h3 id="关系映射Mapping"><a href="#关系映射Mapping" class="headerlink" title="关系映射Mapping"></a>关系映射Mapping</h3><p>在实体表中，添加主子表对象（在主表中添加子表时使用对象替换外键属性），并使用<code>@ManyToOne</code>（或其他关联关系描述）、<code>@JoinColumn(value = &quot;主表关联字段名&quot;)</code>对该对象进行描述。</p>
<p>在JPQL中使用关联表的字段用以替换外键属性，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// dept是Emp的一个对象属性，使用dept中的deptno用于替换Emp中的外键</span><br><span class="line">@Query(&quot;select e from Emp e where e.dept.deptno = :deptno&quot;)</span><br><span class="line">public List&lt;Emp&gt; findAllByDeptno (Integer deptno);</span><br></pre></td></tr></table></figure>



<h3 id="连接池与Druid"><a href="#连接池与Druid" class="headerlink" title="连接池与Druid"></a>连接池与Druid</h3><h4 id="SpringBoot对连接池的支持"><a href="#SpringBoot对连接池的支持" class="headerlink" title="SpringBoot对连接池的支持"></a>SpringBoot对连接池的支持</h4><ul>
<li>目前SpringBoot默认支持的连接池有dbcp、dbcp2、tomcat、hikari</li>
<li>数据库连接可以使用DataSource池进行自动配置</li>
<li>优先使用的连接池技术顺序<ol>
<li>Tomcat</li>
<li>HikariCP</li>
<li>Commons DBCP</li>
<li>Commons DBCP2</li>
</ol>
</li>
</ul>
<h4 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h4><ul>
<li><p>Druid是阿里巴巴提供的数据库连接池，能够提供强大的监控和扩展功能</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/alibaba/druid">Druid GitHub地址</a>、<a target="_blank" rel="noopener" href="https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter">Spring Boot Starter Druid</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/alibaba/druid/wiki/DruidDataSource%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8">DruidDataSource配置属性列表</a></p>
</li>
<li><p>依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.10&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="程序中使用Druid提供的图形化分析工具"><a href="#程序中使用Druid提供的图形化分析工具" class="headerlink" title="程序中使用Druid提供的图形化分析工具"></a>程序中使用Druid提供的图形化分析工具</h5><ol>
<li><p>在程序入口类中添加如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span><br><span class="line">public DataSource druid()&#123;</span><br><span class="line">    return new DruidDataSource();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public ServletRegistrationBean statViewServlet() &#123;</span><br><span class="line">    // 创建StatViewServlet，绑定到/druid/*路径下</span><br><span class="line">    ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;);</span><br><span class="line">    Map&lt;String, String&gt; param = new HashMap&lt;String, String&gt;();</span><br><span class="line">    // 设置后台访问所需的账号密码</span><br><span class="line">    param.put(&quot;loginUsername&quot;, &quot;admin&quot;);</span><br><span class="line">    param.put(&quot;loginPassword&quot;, &quot;123456&quot;);</span><br><span class="line">    // 允许访问后台的IP地址，“”代表所有均允许</span><br><span class="line">    param.put(&quot;allow&quot;, &quot;&quot;);</span><br><span class="line">    // 禁止访问的IP地址</span><br><span class="line">    param.put(&quot;deny&quot;, &quot;10.10.10.10&quot;);</span><br><span class="line">    bean.setInitParameters(param);</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public FilterRegistrationBean webStatFilter() &#123;</span><br><span class="line">    FilterRegistrationBean bean = new FilterRegistrationBean();</span><br><span class="line">    bean.setFilter(new WebStatFilter());// 设置过滤器，WebStatFilter是阿里巴巴提供的默认过滤器</span><br><span class="line">    bean.addUrlPatterns(&quot;/*&quot;);</span><br><span class="line">    Map&lt;String, String&gt; param = new HashMap&lt;String, String&gt;();</span><br><span class="line">    // 排除静态资源</span><br><span class="line">    param.put(&quot;exclusion&quot;, &quot;*.js,*.css,*.jpg,/druid/*&quot;);</span><br><span class="line">    bean.setInitParameters(param);</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>启动项目，访问<code>地址/druid</code></p>
</li>
</ol>
<h3 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h3><ul>
<li><p>默认情况下，数据库的事务作用范围是在JpaRepository的CURD方法上。</p>
<p>在类或者方法上使用<code>org.springframework.transaction.annotation.Transactional</code>注解，可以使事务提高到该类或者方法。所有RuntimeException及其子类的异常均会被回滚。</p>
<p>这种使用注解的注解方式，成为<strong>声明式事务</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">public void imp() &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>可以使用<code>@Transactional(rollbackFor = Exception.class)</code>来指定触发回滚的异常等级</p>
</li>
<li><p>可以使用<code>@Transactional(propagation = Propagation.NOT_SUPPORTED, readOnly = true)</code>关闭事务</p>
</li>
<li><p>一般情况下，事务处理都要在service层</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://everyseptember.github.io/2019/01/24/Springboot%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B04/" data-id="ckp7osn4r000l0es5d2kfgtff" data-title="Springboot实战笔记4" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Springboot%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B0/" rel="tag">Springboot零散笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Springboot实战笔记3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/01/17/Springboot%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B03/" class="article-date">
  <time class="dt-published" datetime="2019-01-17T12:03:08.000Z" itemprop="datePublished">2019-01-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/01/17/Springboot%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B03/">Springboot实战笔记3</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Web开发"><a href="#Web开发" class="headerlink" title="Web开发"></a>Web开发</h2><ul>
<li>Spring Boot帮我们简化了构架的依赖与配置过程，但在Web开发层面上，让然采用Spring MVC开发的方式</li>
<li>Spring MVC中最重要的环节就是开发Controller控制器</li>
</ul>
<h5 id="上下文数据"><a href="#上下文数据" class="headerlink" title="上下文数据"></a>上下文数据</h5><p>以下三种方式传值方式</p>
<ul>
<li>ModelAndView（推荐）</li>
<li>Model</li>
<li>WebRequest或者原生的HttpServletRequest对象（不推荐）</li>
</ul>
<h5 id="返回方式"><a href="#返回方式" class="headerlink" title="返回方式"></a>返回方式</h5><p>使用<code>@ResponseBody</code>可以将返回值转为json，SpringBoot默认使用的json转化工具是jackson</p>
<h5 id="自定义404和500错误页面配置"><a href="#自定义404和500错误页面配置" class="headerlink" title="自定义404和500错误页面配置"></a>自定义404和500错误页面配置</h5><p>在templates文件夹下新建error文件夹，在error中分别创建404.html和500.html，则可自动配置</p>
<h5 id="controller注解"><a href="#controller注解" class="headerlink" title="controller注解"></a>controller注解</h5><p>在controller类上使用<code>@RestController</code>代替<code>@Controller</code>可以使本类中的所有方法默认返回json而不是页面，相当于<code>@ResponseBody + @Controller</code>。</p>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><h5 id="前台配置"><a href="#前台配置" class="headerlink" title="前台配置"></a>前台配置</h5><p>文件上传前台需要满足的三个条件</p>
<ul>
<li>post提交</li>
<li>具备file组件</li>
<li>表单上传方式设置为<code>enctype=&quot;multipart/form-data&quot;</code></li>
</ul>
<h5 id="后台接收"><a href="#后台接收" class="headerlink" title="后台接收"></a>后台接收</h5><ul>
<li>使用<code>@PostMapping</code>注解，接收post数据</li>
<li>使用<code>@RequestParam</code>注解，与前端name对应一致</li>
<li><code>MultipartFile</code>是一个文件接口，保存了文件上传的数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;/create&quot;)</span><br><span class="line">public ModelAndView create(@RequestParam(&quot;photo&quot;) MultipartFile param) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FileCopyUtils</code>是Spring Boot提供的一个专门的文件复制类，可使用进行文件复制，将文件从temp文件夹放到目标文件夹。</p>
<h5 id="上传配置"><a href="#上传配置" class="headerlink" title="上传配置"></a>上传配置</h5><p>SpringBoot默认的文件上传单个文件最大为1M，单次请求最大数据量为100M；可在properties文件中进行配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 单个文件最大数据</span><br><span class="line">spring.servlet.multipart.max-file-size=5mb</span><br><span class="line"># 单词请求最大数据</span><br><span class="line">spring.servlet.multipart.max-request-size=50mb</span><br><span class="line"># 设置上传默认文件夹</span><br><span class="line">spring.servlet.multipart.location=C:/Users/Lu/Desktop/uploaded/temp</span><br></pre></td></tr></table></figure>

<h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><ol>
<li>自定义Filter类，实现<code>javax.servlet.Filter</code>接口</li>
<li>在入口类添加方法，其返回类型为<code>FilterRegistrationBean</code>，注解使用<code>@Bean</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Bean // @Bean注解的作用是在SpringBoot启动时将方法的返回值放到IoC中</span><br><span class="line">public FilterRegistrationBean filterRegiste() &#123;</span><br><span class="line">   FilterRegistrationBean registrationBean = new FilterRegistrationBean();</span><br><span class="line">   // 创建并注册，AccessRecorderFilter是自定义的Filter类</span><br><span class="line">   registrationBean.setFilter(new AccessRecorderFilter());</span><br><span class="line">   registrationBean.addUrlPatterns(&quot;/*&quot;);</span><br><span class="line">   registrationBean.setName(&quot;AccessRecorder&quot;);</span><br><span class="line">   // 设置排序，如果有多个过滤器，order越小的越优先执行</span><br><span class="line">   registrationBean.setOrder(1);</span><br><span class="line">   return registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Web容器"><a href="#Web容器" class="headerlink" title="Web容器"></a>Web容器</h3><ul>
<li>Tomcat：默认的</li>
<li>Jetty：性能优秀的内嵌Web容器，适用于长连接</li>
<li>Undertow：非阻塞Web容器，性能优异，适用于高并发</li>
</ul>
<h4 id="替换web容器"><a href="#替换web容器" class="headerlink" title="替换web容器"></a>替换web容器</h4><ol>
<li>在pom.xml中移除spring-boot-starter-web对Tomcat的依赖</li>
<li>添加对其他容器的依赖</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">      &lt;exclusions&gt;</span><br><span class="line">         &lt;!-- 移除原来对tomcat的依赖 --&gt;</span><br><span class="line">         &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">         &lt;/exclusion&gt;</span><br><span class="line">      &lt;/exclusions&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://everyseptember.github.io/2019/01/17/Springboot%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B03/" data-id="ckp7osn4q000j0es5hwfna6l0" data-title="Springboot实战笔记3" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Springboot%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B0/" rel="tag">Springboot零散笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Springboot实战笔记2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/01/16/Springboot%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B02/" class="article-date">
  <time class="dt-published" datetime="2019-01-16T11:20:59.000Z" itemprop="datePublished">2019-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/01/16/Springboot%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B02/">Springboot实战笔记2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Thymeleaf模板引擎入门"><a href="#Thymeleaf模板引擎入门" class="headerlink" title="Thymeleaf模板引擎入门"></a>Thymeleaf模板引擎入门</h2><h3 id="Thymeleaf的特点"><a href="#Thymeleaf的特点" class="headerlink" title="Thymeleaf的特点"></a>Thymeleaf的特点</h3><ul>
<li>Thymeleaf优点<ul>
<li>主流唯一的前后端通用引擎，静态html嵌入标签属性，浏览器可以直接打开模板文件，便于前后端联调</li>
<li>springboot官方推荐方案</li>
</ul>
</li>
<li>Thymeleaf缺点<ul>
<li>模板必须返回xml规范</li>
<li>慢</li>
</ul>
</li>
</ul>
<h3 id="使用Thymeleaf"><a href="#使用Thymeleaf" class="headerlink" title="使用Thymeleaf"></a>使用Thymeleaf</h3><ol>
<li><p>引入Thymeleaf的命名空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>使用th标签</p>
</li>
<li><p>调用格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">th:标签=&quot;#&#123;属性&#125;&quot;</span><br><span class="line">#&#123;&#125;表示读取常量</span><br><span class="line">$&#123;&#125;表示读取变量</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="Thymeleaf迭代"><a href="#Thymeleaf迭代" class="headerlink" title="Thymeleaf迭代"></a>Thymeleaf迭代</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">th:each=&quot;object,stat:$&#123;list&#125;&quot;、</span><br><span class="line">其中：</span><br><span class="line">	object是每次迭代产生的对象</span><br><span class="line">	list是被迭代的数据集</span><br><span class="line">	stat表示当前的迭代状态，会有许多属性</span><br></pre></td></tr></table></figure>

<h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><p>使用#strings，#dates，#numbers等方法</p>
<h4 id="分支与判断"><a href="#分支与判断" class="headerlink" title="分支与判断"></a>分支与判断</h4><ul>
<li>th属性中使用三目运算符<ul>
<li><code>th:text=&quot;$&#123;emp.comm&#125; != null ? $&#123;emp.comm&#125; : &#39;N/A&#39;&quot;</code></li>
<li>表达方式与java相同</li>
</ul>
</li>
<li>th:if / th:unless判断标签是否输出<ul>
<li><code>th:if=&quot;$&#123;size &gt; 0&#125;&quot;</code></li>
<li><code>th:unless=&quot;$&#123;size &gt; 0&#125;&quot;</code></li>
<li>if在判断为真的时候成立，unless在判断为假的时候成立</li>
</ul>
</li>
<li>多分支判断<ul>
<li><code>th:swith=&quot;$&#123;&#125;&quot; th:case=&quot;&quot;</code></li>
<li><code>th:case=&quot;*&quot;</code>表示除已列出以外情况的所有其他情况</li>
</ul>
</li>
</ul>
<h4 id="创建模板与引用模板"><a href="#创建模板与引用模板" class="headerlink" title="创建模板与引用模板"></a>创建模板与引用模板</h4><ol>
<li>新建一个html文件</li>
<li>在要创建为模板的标签中添加<code>th:fragment=&quot;模板名称&quot; </code></li>
<li>在引用文件中使用<code>&lt;div th:insert=&quot;模板文件名 :: 模板名称&quot;&gt;&lt;/div&gt;</code>调用模板</li>
</ol>
<h4 id="获取请求参数"><a href="#获取请求参数" class="headerlink" title="获取请求参数"></a>获取请求参数</h4><ul>
<li><code>$&#123;param.xxx&#125;</code>用于获取请求参数<ul>
<li>相当于<code>request.getParameter(&#39;xxx&#39;)</code></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://everyseptember.github.io/2019/01/16/Springboot%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B02/" data-id="ckp7osn4o000h0es58abhekr6" data-title="Springboot实战笔记2" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Springboot%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B0/" rel="tag">Springboot零散笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Springboot实战笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/01/14/Springboot%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2019-01-14T10:49:49.000Z" itemprop="datePublished">2019-01-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/01/14/Springboot%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/">Springboot实战笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Spring-Boot常用配置"><a href="#Spring-Boot常用配置" class="headerlink" title="Spring Boot常用配置"></a>Spring Boot常用配置</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><ul>
<li>java：源码</li>
<li>resource：资源位置<ul>
<li>static：静态资源（js、css、图片等）</li>
<li>template：动态页面（模板文件位置）</li>
<li>application.properties：核心配置文件</li>
</ul>
</li>
</ul>
<h3 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h3><h4 id="常用配置项"><a href="#常用配置项" class="headerlink" title="常用配置项"></a>常用配置项</h4><table>
<thead>
<tr>
<th align="left">web常用配置项</th>
<th align="left">默认值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">debug</td>
<td align="left">false</td>
<td align="left">开启/调试模式关闭</td>
</tr>
<tr>
<td align="left">server.port</td>
<td align="left">8080</td>
<td align="left">服务器端口</td>
</tr>
<tr>
<td align="left">server.servlet.context-path</td>
<td align="left">/</td>
<td align="left">应用上下文</td>
</tr>
<tr>
<td align="left">spring.http.encoding.charset</td>
<td align="left">utf-8</td>
<td align="left">默认字符集编码</td>
</tr>
<tr>
<td align="left">spring.thymeleaf.cache</td>
<td align="left">true</td>
<td align="left">开启/关闭页面缓存</td>
</tr>
<tr>
<td align="left">spring.mvc.date-format</td>
<td align="left"></td>
<td align="left">日期输入格式</td>
</tr>
<tr>
<td align="left">spring.jackson.date-format</td>
<td align="left"></td>
<td align="left">json输出的日期</td>
</tr>
<tr>
<td align="left">spring.jackson.time-zone</td>
<td align="left"></td>
<td align="left">设置GMT时区</td>
</tr>
</tbody></table>
<h4 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h4><ul>
<li>UTF-8只包含了20000+个中文字符，对于生僻字显示不了</li>
<li>开发时关闭Thymeleaf缓存，同时配合自动构建，可以实现热部署，提高开发效率</li>
</ul>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>Springboot默认使用logback</p>
<h4 id="常用配置项-1"><a href="#常用配置项-1" class="headerlink" title="常用配置项"></a>常用配置项</h4><table>
<thead>
<tr>
<th>日志常用配置项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>logging.file</td>
<td></td>
<td>日志输出的文件</td>
</tr>
<tr>
<td>logging.level.ROOT</td>
<td>info</td>
<td>设置日志的输出级别</td>
</tr>
<tr>
<td>logging.level.*</td>
<td>info</td>
<td>定义指定包的输出级别</td>
</tr>
<tr>
<td>logging.config</td>
<td>logback-spring.xml</td>
<td>日志的配置文件</td>
</tr>
</tbody></table>
<h4 id="PS-1"><a href="#PS-1" class="headerlink" title="PS"></a>PS</h4><ul>
<li>日志级别 debug-&gt;info-&gt;warn-&gt;error，默认级别为info，设置debug为true，会出现debug以上的级别</li>
<li>logging.level.root代表全局设置，只会显示root配置级别及以上的日志；logging.level.*可以指定包的显示级别</li>
<li>指定logging.config参数后application.properties中的日志配置将会失效，转而使用配置文件中的设置</li>
</ul>
<h3 id="Spring-Boot配置文件"><a href="#Spring-Boot配置文件" class="headerlink" title="Spring Boot配置文件"></a>Spring Boot配置文件</h3><p>SpringBoot支持两种格式的配置文件</p>
<ul>
<li>属性文件：application.properties</li>
<li>yaml：application.yml</li>
</ul>
<p>当同时存在两种格式文件，以properties为准</p>
<h4 id="yaml"><a href="#yaml" class="headerlink" title="yaml"></a>yaml</h4><p>yaml是一种简洁的非标记语言。yaml以数据为中心，使用空白、缩进、分行组织数据，从而更加简洁易读。</p>
<h5 id="yaml语法格式"><a href="#yaml语法格式" class="headerlink" title="yaml语法格式"></a>yaml语法格式</h5><ul>
<li>标准格式：key:（空格）value</li>
<li>使用空格代表层级关系，以<code>:</code>结束</li>
</ul>
<h3 id="环境配置文件"><a href="#环境配置文件" class="headerlink" title="环境配置文件"></a>环境配置文件</h3><ul>
<li>SpringBoot可针对不同的环境提供不同的Profile文件</li>
<li>Profile文件的默认命名格式为application-{env}.yml</li>
<li>使用spring.profiles.active选项来指定不同的profile</li>
<li>不同环境日志系统的配置需要用logback-spring.xml修改</li>
</ul>
<h3 id="Spring-Boot自定义配置"><a href="#Spring-Boot自定义配置" class="headerlink" title="Spring Boot自定义配置"></a>Spring Boot自定义配置</h3><p>Spring Boot内置的配置项远远不能支撑我们的程序运行，在项目设计的时候，往往因为扩展性的需要，项目需要预留很多自定义设置项，Spring Boot允许我们配置自定义选项。</p>
<h4 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h4><ul>
<li>@Value单个属性注入<ul>
<li>在类属性添加<code>@Value($&#123;name&#125;)</code>注解，便可将不同的配置注入到当前属性中</li>
</ul>
</li>
<li>@ConfigurationProperties类型安全加载<ul>
<li>在实体类添加<code>@Component</code>，表明这是一个组件类，这样Spring Boot启动时会加载该类</li>
<li>在实体类添加<code>@ConfigurationProperties(prefix=&quot;app&quot;)</code>，可以添加所有配置中前缀为app的配置，并自动与属性匹配（需实体类属性与配置文件属性命名方式相对应）</li>
<li>在调用实体类位置添加<code>@Autowired</code>或<code>@Resource</code>注解，即可实现动态注入</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://everyseptember.github.io/2019/01/14/Springboot%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/" data-id="ckp7osn4n000f0es57gjnc7j3" data-title="Springboot实战笔记" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Springboot%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B0/" rel="tag">Springboot零散笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Springboot笔记2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/01/10/Springboot%E7%AC%94%E8%AE%B02/" class="article-date">
  <time class="dt-published" datetime="2019-01-10T11:19:17.000Z" itemprop="datePublished">2019-01-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/01/10/Springboot%E7%AC%94%E8%AE%B02/">Springboot笔记2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h2><h3 id="Springboot三大特性"><a href="#Springboot三大特性" class="headerlink" title="Springboot三大特性"></a>Springboot三大特性</h3><ul>
<li><p>组件自动装配：Web MVC、Web Flux、JDBC等</p>
</li>
<li><p>嵌入式web容器：Tomcat、Jetty及Undertow</p>
</li>
<li><p>生产准备特性：指标、健康检查、外部化检查等</p>
</li>
</ul>
<h4 id="组件自动装配"><a href="#组件自动装配" class="headerlink" title="组件自动装配"></a>组件自动装配</h4><ol>
<li>激活自动装配：@EnableAutoConfiguration</li>
<li>配置：/META-INF/spring.factories</li>
<li>实现：XXXAutoConfiguration</li>
</ol>
<h4 id="嵌入式web容器"><a href="#嵌入式web容器" class="headerlink" title="嵌入式web容器"></a>嵌入式web容器</h4><ul>
<li>Web Servlet：Tomcat、Jetty及Undertow</li>
<li>Web Reactive：Netty Web Server</li>
</ul>
<h4 id="生产准备特性"><a href="#生产准备特性" class="headerlink" title="生产准备特性"></a>生产准备特性</h4><ul>
<li>指标：/actuator/metrics</li>
<li>健康检查：/actuator/health</li>
<li>外部化配置：/actuator/configprops</li>
</ul>
<h2 id="Web应用"><a href="#Web应用" class="headerlink" title="Web应用"></a>Web应用</h2><h3 id="传统Servlet应用"><a href="#传统Servlet应用" class="headerlink" title="传统Servlet应用"></a>传统Servlet应用</h3><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h4 id="Servlet组件"><a href="#Servlet组件" class="headerlink" title="Servlet组件"></a>Servlet组件</h4><ul>
<li>Servlet<ul>
<li>实现<ul>
<li>@WebServlet</li>
<li>HttpServlet</li>
<li>注册</li>
</ul>
</li>
<li>URL映射</li>
<li>注册</li>
</ul>
</li>
<li>Filter</li>
<li>Listener</li>
</ul>
<h4 id="Servlet注册"><a href="#Servlet注册" class="headerlink" title="Servlet注册"></a>Servlet注册</h4><h5 id="Servlet注解"><a href="#Servlet注解" class="headerlink" title="Servlet注解"></a>Servlet注解</h5><ul>
<li>@ServletComponentScan +<ul>
<li>@WebServlet</li>
<li>@WebFilter</li>
<li>@WebListener</li>
</ul>
</li>
</ul>
<h5 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h5><h5 id="RegistrationBean"><a href="#RegistrationBean" class="headerlink" title="RegistrationBean"></a>RegistrationBean</h5><h4 id="异步非阻塞：异步Servlet、非阻塞Servlet"><a href="#异步非阻塞：异步Servlet、非阻塞Servlet" class="headerlink" title="异步非阻塞：异步Servlet、非阻塞Servlet"></a>异步非阻塞：异步Servlet、非阻塞Servlet</h4><h5 id="异步Servlet"><a href="#异步Servlet" class="headerlink" title="异步Servlet"></a>异步Servlet</h5><ul>
<li>javax.servlet.ServletRequest#startAsync()</li>
<li>javax.servlet.AsyncContext</li>
</ul>
<h5 id="非阻塞Servlet"><a href="#非阻塞Servlet" class="headerlink" title="非阻塞Servlet"></a>非阻塞Servlet</h5><ul>
<li>javax.servlet.ServletInputStream#setReadListener<ul>
<li>javax.servlet.ReadListener</li>
</ul>
</li>
<li>javax.servlet.ServletOutputStream#setWriteListener<ul>
<li>javax.servlet.WriteListener</li>
</ul>
</li>
</ul>
<h3 id="Spring-Web-MVC应用"><a href="#Spring-Web-MVC应用" class="headerlink" title="Spring Web MVC应用"></a>Spring Web MVC应用</h3><h4 id="​Web-MVC视图"><a href="#​Web-MVC视图" class="headerlink" title="​Web MVC视图"></a>​Web MVC视图</h4><ul>
<li>ViewResolver</li>
<li>View</li>
</ul>
<h5 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h5><ul>
<li>Thymeleaf</li>
<li>Freemarker</li>
<li>JSP</li>
</ul>
<h5 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h5><ul>
<li>ContentNegotiationConfigurer</li>
<li>ContentNegotiationStrategy</li>
<li>ContentNegotiatingViewResolver</li>
</ul>
<h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><ul>
<li>@ExceptionHandler</li>
<li>HandlerExceptionResolver<ul>
<li>ExceptionHandlerExceptionResolver</li>
</ul>
</li>
<li>BasicErrorController (Spring Boot)</li>
</ul>
<h4 id="Web-MVCREST"><a href="#Web-MVCREST" class="headerlink" title="Web MVCREST"></a>Web MVCREST</h4><h4 id="Web-MVC核心"><a href="#Web-MVC核心" class="headerlink" title="Web MVC核心"></a>Web MVC核心</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://everyseptember.github.io/2019/01/10/Springboot%E7%AC%94%E8%AE%B02/" data-id="ckp7osn4w000r0es5diqk4enn" data-title="Springboot笔记2" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Springboot%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B0/" rel="tag">Springboot零散笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Springboot笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/01/05/Springboot%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2019-01-05T05:39:44.000Z" itemprop="datePublished">2019-01-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/01/05/Springboot%E7%AC%94%E8%AE%B0/">Springboot笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="Spring-Data"><a href="#Spring-Data" class="headerlink" title="Spring Data"></a>Spring Data</h3><p>使用Spring Data（一种借口）替代dao层，可有效提高代码复用。</p>
<h3 id="DDD模型（领域驱动设计）"><a href="#DDD模型（领域驱动设计）" class="headerlink" title="DDD模型（领域驱动设计）"></a>DDD模型（领域驱动设计）</h3><p>它像是更小粒度的迭代设计，它的最小单元是<code>领域模型(Domain Model)</code>，所谓领域模型就是能够精确反映领域中某一知识元素的载体，这种知识的获取需要通过与<code>领域专家(Domain Expert)</code>进行频繁的沟通才能将专业知识转化为领域模型。领域模型无关技术，具有高度的业务抽象性，它能够精确的描述领域中的知识体系；同时它也是独立的，我们还需要学会如何让它具有表达性，让模型彼此之间建立关系，形成完整的领域架构。通常我们可以用象形图或一种<code>通用的语言(Ubiquitous Language)</code>去描述它们之间的关系。在此之上，我们就可以进行<code>领域中的代码设计(Domain Code Design)</code>。</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b6ec06d6b594">https://www.jianshu.com/p/b6ec06d6b594</a></p>
<h3 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h3><p>可以拆分成两个注解@ResponseBody及@Controller，分别表示可返回对象以及这是一个控制器。</p>
<h3 id="Repository对Controller采用构造器的方式注入"><a href="#Repository对Controller采用构造器的方式注入" class="headerlink" title="Repository对Controller采用构造器的方式注入"></a>Repository对Controller采用构造器的方式注入</h3><p>构造器的方式使Repository不可修改，且可以提早进行初始化。</p>
<h3 id="转发与接收请求"><a href="#转发与接收请求" class="headerlink" title="转发与接收请求"></a>转发与接收请求</h3><p>@PostMapping转发请求</p>
<p>@RequestParam可以自动匹配参数</p>
<h2 id="Web-Flux"><a href="#Web-Flux" class="headerlink" title="Web Flux"></a>Web Flux</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>传统NIO：同步非阻塞；</p>
<p>Reactor：异步非阻塞的Reactive实现；</p>
<p>Flux：0到N的对象；</p>
<p>Mono：0到1的对象；</p>
<h3 id="路由函数"><a href="#路由函数" class="headerlink" title="路由函数"></a>路由函数</h3><p>采用路由函数可替代Mapping注解。</p>
<h3 id="λ表达式个人理解"><a href="#λ表达式个人理解" class="headerlink" title="λ表达式个人理解"></a>λ表达式个人理解</h3><p><code>(parameters) -&gt;&#123; statements; &#125;</code></p>
<p>λ表达式是一个匿名函数，返回的是抽象方法的具体实现；parameters是该方法的参数列表，statements即该方法的方法体。</p>
<h2 id="多模块"><a href="#多模块" class="headerlink" title="多模块"></a>多模块</h2><p>在主工程pom.xml中调整packaging为<packaging>pom</packaging></p>
<p>拆分为web、persistence、model三个模块，并根据pom.xml处理相关依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">模型层：model</span><br><span class="line">持久层：persistence</span><br><span class="line">表示层：web</span><br><span class="line">web层依赖于persistence，persistence依赖于model</span><br></pre></td></tr></table></figure>



<h2 id="项目打包"><a href="#项目打包" class="headerlink" title="项目打包"></a>项目打包</h2><ol>
<li>指定Main-Class<ul>
<li>将原来在project的pom.xml的plugins配置放到主模块的pom.xml中去</li>
</ul>
</li>
<li>打包<ul>
<li>JAR、WAR</li>
<li>通过修改主module中pom.xml中packaging的形式修改打包方式</li>
<li>使用IDEA打包<ul>
<li>坑：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u011624972/article/details/58591825">https://blog.csdn.net/u011624972/article/details/58591825</a></li>
</ul>
</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://everyseptember.github.io/2019/01/05/Springboot%E7%AC%94%E8%AE%B0/" data-id="ckp7osn4u000p0es56jkwevut" data-title="Springboot笔记" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Springboot%E7%AC%94%E8%AE%B0/" rel="tag">Springboot笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-搭建Hexo环境" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/04/30/%E6%90%AD%E5%BB%BAHexo%E7%8E%AF%E5%A2%83/" class="article-date">
  <time class="dt-published" datetime="2018-04-30T16:00:00.000Z" itemprop="datePublished">2018-05-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/04/30/%E6%90%AD%E5%BB%BAHexo%E7%8E%AF%E5%A2%83/">云服务搭建Hexo</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="安装配置Hexo"><a href="#安装配置Hexo" class="headerlink" title="安装配置Hexo"></a>安装配置Hexo</h3><p>安装Nodejs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">下载nodejs</span><br><span class="line">wget https://nodejs.org/dist/v8.11.2/node-v8.11.2-linux-x64.tar.xz</span><br><span class="line"></span><br><span class="line">解包</span><br><span class="line">tar xf node-v8.11.2-linux-x64.tar.xz</span><br><span class="line"></span><br><span class="line">建立软连接，此处源目录最好是绝对路径，否则可能会报错</span><br><span class="line">ln -s 源目录/node /usr/local/bin/node</span><br><span class="line">ln -s 源目录/npm /usr/local/bin/npm</span><br><span class="line">ln -s 源目录/npx /usr/local/bin/npx</span><br></pre></td></tr></table></figure>

<p>安装Hexo</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line"></span><br><span class="line">建立软连接</span><br><span class="line">ln -s 源目录/hexo /usr/local/bin/hexo</span><br></pre></td></tr></table></figure>

<h3 id="安装配置Nginx"><a href="#安装配置Nginx" class="headerlink" title="安装配置Nginx"></a>安装配置Nginx</h3><p>阿里云CentOS7自带yum源安装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx -y</span><br></pre></td></tr></table></figure>

<p>启动服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">手动启动</span><br><span class="line">systemctl start nginx</span><br><span class="line"></span><br><span class="line">设置开机自启</span><br><span class="line">systemctl enable nginx</span><br></pre></td></tr></table></figure>

<p>开放阿里云80端口，访问测试</p>
<p><img src="http://wx2.sinaimg.cn/large/be961c2aly1fs9yb2mhahj21cp0ggq3z.jpg"></p>
<p>修改配置文件，打开/etc/nginx/nginx.conf，修改root以配置博客默认文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    ...</span><br><span class="line">    root         /usr/share/nginx/blog;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在/usr/share/nginx/下新建blog文件夹作为展示博客的根目录，重启Nginx</p>
<h3 id="hexo配置"><a href="#hexo配置" class="headerlink" title="hexo配置"></a>hexo配置</h3><p>创建hexo目录，在文件夹中初始化hexo</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<p>修改hexo目录下_config.yml文件，修改public_dir使其指向Nginx下的博客目录，便可以直接生成到网站目录下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public_dir: /usr/share/nginx/blog</span><br></pre></td></tr></table></figure>

<p>在hexo目录下生成博客，并访问测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<p><img src="http://wx2.sinaimg.cn/large/be961c2aly1fs9yb5asiij21fu0u0wv0.jpg"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://everyseptember.github.io/2018/04/30/%E6%90%AD%E5%BB%BAHexo%E7%8E%AF%E5%A2%83/" data-id="ckp7osn4y000u0es5hypghmx6" data-title="云服务搭建Hexo" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BF%90%E7%BB%B4/" rel="tag">运维</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Freemarker/" rel="tag">Freemarker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">Java多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/" rel="tag">Java核心技术</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatis/" rel="tag">MyBatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL%E5%9F%BA%E7%A1%80/" rel="tag">MySQL基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" rel="tag">MySQL存储引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSM/" rel="tag">SSM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-MVC/" rel="tag">Spring MVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Web/" rel="tag">Spring Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Springboot%E7%AC%94%E8%AE%B0/" rel="tag">Springboot笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Springboot%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B0/" rel="tag">Springboot零散笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" rel="tag">二分查找</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" rel="tag">分库分表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/" rel="tag">参数配置</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%93%88%E5%B8%8C/" rel="tag">哈希</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE/" rel="tag">图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="tag">基础知识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A0%86/" rel="tag">堆</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/" rel="tag">字符串匹配</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/" rel="tag">开发模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%85%A2SQL%E6%97%A5%E5%BF%97/" rel="tag">慢SQL日志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/" rel="tag">执行计划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%A3%E5%88%97%E8%A1%A8/" rel="tag">散列表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9E%B6%E6%9E%84/" rel="tag">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91/" rel="tag">树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/" rel="tag">红黑树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/" rel="tag">线性表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%90%E7%BB%B4/" rel="tag">运维</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A1%A8/" rel="tag">非线性表</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Freemarker/" style="font-size: 10px;">Freemarker</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 10px;">Java多线程</a> <a href="/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/" style="font-size: 11.67px;">Java核心技术</a> <a href="/tags/MyBatis/" style="font-size: 10px;">MyBatis</a> <a href="/tags/MySQL/" style="font-size: 18.33px;">MySQL</a> <a href="/tags/MySQL%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">MySQL基础</a> <a href="/tags/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" style="font-size: 10px;">MySQL存储引擎</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/SSM/" style="font-size: 16.67px;">SSM</a> <a href="/tags/Spring/" style="font-size: 11.67px;">Spring</a> <a href="/tags/Spring-MVC/" style="font-size: 11.67px;">Spring MVC</a> <a href="/tags/Spring-Web/" style="font-size: 10px;">Spring Web</a> <a href="/tags/Springboot%E7%AC%94%E8%AE%B0/" style="font-size: 10px;">Springboot笔记</a> <a href="/tags/Springboot%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B0/" style="font-size: 20px;">Springboot零散笔记</a> <a href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" style="font-size: 10px;">二分查找</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 13.33px;">二叉树</a> <a href="/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" style="font-size: 10px;">分库分表</a> <a href="/tags/%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/" style="font-size: 10px;">参数配置</a> <a href="/tags/%E5%93%88%E5%B8%8C/" style="font-size: 10px;">哈希</a> <a href="/tags/%E5%9B%BE/" style="font-size: 10px;">图</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 10px;">基础知识</a> <a href="/tags/%E5%A0%86/" style="font-size: 10px;">堆</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/" style="font-size: 10px;">字符串匹配</a> <a href="/tags/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">开发模式</a> <a href="/tags/%E6%85%A2SQL%E6%97%A5%E5%BF%97/" style="font-size: 10px;">慢SQL日志</a> <a href="/tags/%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/" style="font-size: 10px;">执行计划</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">排序</a> <a href="/tags/%E6%95%A3%E5%88%97%E8%A1%A8/" style="font-size: 10px;">散列表</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 20px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 18.33px;">数据结构</a> <a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 13.33px;">架构</a> <a href="/tags/%E6%A0%91/" style="font-size: 13.33px;">树</a> <a href="/tags/%E6%A1%86%E6%9E%B6/" style="font-size: 16.67px;">框架</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a> <a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 10px;">索引</a> <a href="/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/" style="font-size: 10px;">红黑树</a> <a href="/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/" style="font-size: 10px;">线性表</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a> <a href="/tags/%E8%BF%90%E7%BB%B4/" style="font-size: 11.67px;">运维</a> <a href="/tags/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A1%A8/" style="font-size: 15px;">非线性表</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/19/CAP/">CAP</a>
          </li>
        
          <li>
            <a href="/2020/06/09/%E6%9E%B6%E6%9E%84-Spring%20Web%E4%B8%8ESpring%20MVC/">架构-Spring Web与Spring MVC</a>
          </li>
        
          <li>
            <a href="/2020/06/09/%E6%9E%B6%E6%9E%84-Spring/">架构-Spring</a>
          </li>
        
          <li>
            <a href="/2020/06/08/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/">架构-Java基础</a>
          </li>
        
          <li>
            <a href="/2020/06/08/%E6%9E%B6%E6%9E%84-Java%E5%9F%BA%E7%A1%80/">架构-Java基础</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 lu<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>