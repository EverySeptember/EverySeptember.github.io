<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>这里是lu</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="这里是lu">
<meta property="og:url" content="http://everyseptember.github.io/page/2/index.html">
<meta property="og:site_name" content="这里是lu">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="lu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="这里是lu" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">这里是lu</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://everyseptember.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-设计模式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2019-07-28T03:55:48.000Z" itemprop="datePublished">2019-07-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>设计模式代表了软件设计的最佳实践，是经过不断总结提炼出来的代码设计经验的分类总结，这些模式或者可以简化代码，或者可以是代码逻辑开起来清晰，或者对功能扩展很方便。</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>根据使用场景，设计模式可以分为三大类：</p>
<ul>
<li>创建型模式：对对象的实例化过程进行抽象，是系统不用关心对象的创建。类创建者模式通过使用继承改变实例化的类，对象创建模式则使用代理来实例化所需要的对象。<ul>
<li>工厂模式</li>
<li>原型模式</li>
<li>构建者模式</li>
<li>单例模式</li>
</ul>
</li>
<li>结构型模式：通过对多个类和多个对象进行组合得到复杂结构的类，一般使用继承或者成员变量引用的形式实现。<ul>
<li>适配器模式</li>
<li>桥接模式</li>
<li>过滤器模式</li>
<li>组合模式</li>
<li>装饰者模式</li>
<li>门面模式</li>
<li>享元模式</li>
<li>代理模式</li>
</ul>
</li>
<li>行为者模式：行为模式不仅表达了类和对象，还表达了他们之间的交互，设计到对象和算法的分配。<ul>
<li>责任链模式</li>
<li>命令模式</li>
<li>解释器模式</li>
<li>迭代器模式</li>
<li>中介者模式</li>
<li>备忘录模式</li>
<li>观察者模式</li>
<li>状态模式</li>
<li>空对象模式</li>
<li>策略模式</li>
<li>模板方法模式</li>
<li>访问者模式</li>
</ul>
</li>
</ul>
<h2 id="常用模式"><a href="#常用模式" class="headerlink" title="常用模式"></a>常用模式</h2><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>责任链模式是把多个对象串起来形成一个链式结构，让每个对象都对时间发送者的请求进行处理，使得事件发起者与事件处理者之间解耦。</p>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><ul>
<li>Tomcat中的Valva链：责任链链中的每个对象都有下一个对象的引用</li>
<li>Tomcat中的Filter链：同一个链管理工厂里存放了所有的对象</li>
</ul>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>当一个请求需要根据参数的不同交由不同对象来处理的时候</li>
<li>当一个请求需要固定对象顺序处理，并且可扩展地在固定顺序里插入新的对象进行处理的时候</li>
</ul>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>封装了对象的创建过程，调用者使用工厂的具体方法，传入相应参数便可获得对应的对象。</p>
<h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><ul>
<li>Spring 框架中 BeanFactory</li>
</ul>
<h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>不同条件创建不同实例，用于统一管理Bean</li>
<li>不同条件下调用不同工厂方法获取不同场景下的Bean</li>
</ul>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式提供一个创建对象的接口，但是多次调用该接口返回的是同一个实例的引用，目的是保证只有一个实例，并且提供一个访问这个实例的统一接口。</p>
<h4 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h4><p>Spring中单例Bean的创建。</p>
<p>AbstractBeanFactory类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doGetBean</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">final</span> String name, <span class="keyword">final</span> Class requiredType, <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">    Object bean = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决set循环依赖</span></span><br><span class="line">    Object sharedInstance = getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 创建单件bean.</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">            sharedInstance = getSingleton(beanName, <span class="keyword">new</span> ObjectFactory() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//创建原型bean</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建request作用域bean</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">            ...</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory singletonFactory)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(beanName, <span class="string">&quot;&#x27;beanName&#x27; must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">        Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            beforeSingletonCreation(beanName);</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                singletonObject = singletonFactory.getObject();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                afterSingletonCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            addSingleton(beanName, singletonObject);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="keyword">this</span>.singletonObjects.put(beanName, (singletonObject != <span class="keyword">null</span> ? singletonObject : NULL_OBJECT));</span><br><span class="line">        <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">        <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">        <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map singletonObjects = CollectionFactory.createConcurrentMapIfPossible(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://www.funtl.com/assets/5879294-3013e4bf12ef0274.png" alt="Spring创建单例Bean"></p>
<p>Spring 的 <code>bean</code> 工厂管理的单例模式管理的是多个 <code>bean</code> 实例的单例，是工厂模式管理所有的 <code>bean</code>,而每个 <code>bean</code> 的创建又使用了单例模式。</p>
<h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>同一个JVM应用的不同模块需要使用同一个对象实例进行信息共享</li>
<li>需要同一个实例来生成全局统一的序列号</li>
</ul>
<h3 id="原型设计模式"><a href="#原型设计模式" class="headerlink" title="原型设计模式"></a>原型设计模式</h3><p>通过复制一个现有的实例来创建一个对象。相比单例模式，原型模式是每次创建一个对象。</p>
<h4 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h4><p>Spring中原型Bean的创建。创建原型Bean需要在xml中特殊说明：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xxx.demo.Hello&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>当需要使用一个独立Bean的时候</p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>定义一系列算法对象，使用的时候可以使他们互相替换</p>
<h4 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h4><ul>
<li>Spring 中 bean 实例化策略</li>
<li>Spring 中 AOP 代理策略</li>
<li>Tomcat 中 Digester 解析 server.xml</li>
</ul>
<h4 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h4><p>运行时根据条件的不同使用不同的策略处理一个事情，与责任链不同在于，责任链是一个链条，一个事情可以被责任链里面所有节点处理，而 策略模式则是只有有一个对象来处理。</p>
<h3 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h3><p>即接口</p>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>当需要对外屏蔽一个系统的复杂性时候可以考虑使用门面模式对外提供简单可读性高的接口类</li>
<li>当需要对外部暴露系统一部分权限的接口时候可以考虑使用门面模式减少系统权限</li>
<li>当系统需要调用不同服务汇总后在对外提供服务时候可以考虑使用门面模式对外屏蔽细节，只暴露一个接口</li>
</ul>
<h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>作用是对对象已有功能进行增强，但是不改变原有对象结构。避免了通过继承方式进行扩充导致的类体系臃肿。</p>
<h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><p>在不改变原有类结构基础上，新增或者限制或者改造功能时候</p>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>为两个接口之间的互通提供了一种手段</p>
<h4 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>两个系统交互时候由于接口参数不一致没法直接对接，则可以使用适配器接口做参数转换</li>
<li>适配器模式经常是在一个系统或者设计已经定型时候使用，而不是在初始设计的时候。一般是在不影响现有业务的情况下，通过适配方式统一接口</li>
</ul>
<h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>使用一个抽象类定义了一个模板，这个模板里定义了一系列的接口，子类只需要继承该抽象类并根据需要重写一部分接口。</p>
<h4 id="使用场景-5"><a href="#使用场景-5" class="headerlink" title="使用场景"></a>使用场景</h4><p>当多个子类具有共同的操作流程逻辑，并且其中某些流程节点操作需要自己定制化的时候</p>
<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>将一个复制对象的创建屏蔽到接口内部，用户使用的时候只需要传递固定的参数，内部就会执行复杂逻辑然后返回用户需要的对象，用户不需要知道创建的细节</p>
<h4 id="案例-5"><a href="#案例-5" class="headerlink" title="案例"></a>案例</h4><p>Mybatis 中的 SqlSessionFactoryBuilder</p>
<h4 id="使用场景-6"><a href="#使用场景-6" class="headerlink" title="使用场景"></a>使用场景</h4><p>当一个对象比较复杂且容易出错的时候，可以使用这个模式去屏蔽细节</p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>定义了当一个对象状态或属性发生变化的时候，通知其他对这些状态感兴趣的对象。也叫发布-订阅模式。</p>
<h4 id="案例-6"><a href="#案例-6" class="headerlink" title="案例"></a>案例</h4><p>MQ</p>
<h4 id="使用场景-7"><a href="#使用场景-7" class="headerlink" title="使用场景"></a>使用场景</h4><p>满足发布-订阅条件的，当一个对象装填或属性发生变化时，需要把这种变化通知到订阅者的时候。</p>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>通过把命令封装成一个对象，命令发出者不用管谁来接收，命令接收者也不用关心是谁发出命令，实现了发送者与接收者之间的解耦。</p>
<h4 id="案例-7"><a href="#案例-7" class="headerlink" title="案例"></a>案例</h4><p>tomcat</p>
<h4 id="使用场景-8"><a href="#使用场景-8" class="headerlink" title="使用场景"></a>使用场景</h4><p>当时间发送者和接收者需要完全解耦的时候</p>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>一个软件实体应当对扩展开发，对修改关闭。</p>
<p>即在再设计一个模块的时候，应当是这个模块可以在不被修改的前提下被扩展。这是面向对象设计的基石，也是最重要的原则。</p>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><ul>
<li>一个类对另一个类的依赖是建立在最小的接口上</li>
<li>客户端不应该去依赖它不需要的接口</li>
</ul>
<h3 id="组合-聚合复用原则"><a href="#组合-聚合复用原则" class="headerlink" title="组合/聚合复用原则"></a>组合/聚合复用原则</h3><p>尽量使用组合/复用，尽量减少继承。</p>
<p>在一个新对象里使用一些已有的对象，使之成为新对象的一部分。达到使用已有对象功能复用的目的。</p>
<h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>任何可以使用基类的地方，一定可以使用其子类；反过来则不一定。</p>
<h3 id="最少知识原则"><a href="#最少知识原则" class="headerlink" title="最少知识原则"></a>最少知识原则</h3><p>一个对象应该尽可能少地了解其他对象。</p>
<p>一个对象只与它直接相关的对象进行通信，如果需要第三方的功能，则需要通过其直接关联的对象去调用。</p>
<h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><p>客户端依赖于抽象的接口而不是具体实现。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://everyseptember.github.io/2019/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" data-id="ckp7o8tjx002110mw50qdf3n4" data-title="设计模式" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-数据库-MySQL-参数配置" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/07/24/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL-%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/" class="article-date">
  <time class="dt-published" datetime="2019-07-24T12:38:29.000Z" itemprop="datePublished">2019-07-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/07/24/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL-%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/">MySQL调优-参数配置</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="设置参数的方法"><a href="#设置参数的方法" class="headerlink" title="设置参数的方法"></a>设置参数的方法</h4><p>以下方法优先级递减，第一种关闭当前session后失效，第二种当前服务进程关闭后失效</p>
<ul>
<li>set [session] 参数名 = 参数值; #设置当前会话（连接）参数</li>
<li>set global 参数名 = 参数值; #设置全局参数，部分设置需要新建会话才生效</li>
<li>设置应用<a target="_blank" rel="noopener" href="https://blog.51cto.com/moerjinrong/2092791">配置文件</a><ul>
<li>Windows下将配置文件my.ini存放到应用程序根目录</li>
<li>Linux保存到/etc/my.cnf文件</li>
</ul>
</li>
</ul>
<h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><h5 id="connection连接参数"><a href="#connection连接参数" class="headerlink" title="connection连接参数"></a>connection连接参数</h5><ul>
<li><p>max_connections，最大连接数，<code>show VARIABLES like &#39;max_connections&#39;;</code></p>
<p>max_connections 代表数据库同时允许的最大允许连接数</p>
<p>连接有两种常见状态:sleep / query </p>
<p>sleep 代表连接处于闲置状态</p>
<p>query 代表连接正处于处理任务的状态</p>
<p>sleep + query 连接的总量不能超过max_connections的设置值</p>
<p>否则会出现经典错误:”ERROR 1040：Too many connetcions”</p>
</li>
<li><p>Thread%，查看连接状态，<code>show status like &#39;Threads%&#39;;</code></p>
<p>Threads_connected 代表当前已经有多少连接(Sleep+Query)</p>
<p>Threads_created 代表历史总共创建过多少个数据库连接 </p>
<p>Threads_running 代表有几个连接正处于”工作”状态，也是目前的并发数</p>
<p>Threads_cached 共缓存过多少连接.如果我们在MySQL服务器配置文件中设置了thread_cache_size，当客户端断开之后，服务器处理此客户的线程将会缓存起来以响应下一个客户而不是销毁(前提是缓存数未达上限)。</p>
<p>例：<code>set global thread_cache_size=80;</code>（缓存80个数据库缓存连接）</p>
<p>查询MySQL历史运行过程中最大连接数的数量及时点，可根据该值去估算更改缓存大小</p>
<p><code>show status like &#39;Max_used_connections%&#39;;</code></p>
</li>
<li><p>back_log，设置保存多少数据库请求到堆栈（缓冲区）中，<code>show VARIABLES LIKE &#39;back_log&#39;</code></p>
<p>如果MySql的连接数达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源。将会报：<br>unauthenticated user | xxx.xxx.xxx.xxx | NULL | Connect | NULL | login | NULL 的待连接进程时</p>
</li>
<li><p>wait_timeout和interactive_timeout，这两个参数都是至超过一段时间后，数据库连接自动关闭(默认28800秒，即8小时)</p>
<p>interactive_timeout针对交互式连接，wait_timeout针对非交互式连接。</p>
<p>说得直白一点，通过mysql客户端连接数据库是交互式连接，通过jdbc连接数据库是非交互式连接。</p>
<p>查看当前数据库连接详细状况：<code>show processlist;</code></p>
</li>
</ul>
<h5 id="查询缓存（QC）参数"><a href="#查询缓存（QC）参数" class="headerlink" title="查询缓存（QC）参数"></a>查询缓存（QC）参数</h5><p>将结果放入到内存缓存区，之后使用相同（需完全相同，包括字符和大小写）的select语句，将直接从缓存区读取</p>
<p>使用<code>show status like &#39;Qcache%&#39;;</code>查看当前缓存使用情况</p>
<ul>
<li><p>Qcache_free_memory:Query Cache 中目前剩余的内存大小。通过这个参数我们可以较为准确的观察当前系统中的Query Cache内存大小是否足够，是需要增多还是过多了。</p>
</li>
<li><p>Qcache_lowmen_prunes：多少条Query因为内存不足而被清除出Query Cache，通过Qcache_lowmem_prunes和Qcache_free_memory 相互结合，能够更清楚的了解到我们系统中Query Cache的内存大小是否真的足够，是否非常频繁的出现因为内存不足而有Query被换出。这个数字最好是长时间来看，如果这个数字在不断增长，就表示可能碎片化非常严重，或者内存很少。</p>
</li>
<li><p>Qcache_total_blocks：当前Query Cache中block的数量</p>
</li>
<li><p>Qcache_free_blocks：缓存中相邻内存块的个数。如果该值显示过大，则说明Query Cache中的内存碎片较多了。</p>
<p>查询缓存碎片率：Qcache_free_block/Qcache_total_block*100%。如果查询缓存碎片率超过20%，可以用flush query cache整理缓存碎片。Block默认是 4KB ，设置值大对大数据查询有好处，但是如果你查询的都是小数据查询，就容易造成内存碎片和浪费。</p>
</li>
<li><p>Qcache_hits：表示有多少次命中缓存。我们主要可以通过该值来验证我们的查询能缓存的效果。数字越大缓存效果越理想。</p>
</li>
</ul>
<ul>
<li>Qcache_inserts：表示多少次未命中而插入，意思是新来的SQL请求在缓存中未找到，不得不执行查询处理，执行查询处理后把结果insert带查询缓存中。这样的情况次数越多，表示查询缓存 应用到的比较少，效果也就不理想。</li>
</ul>
<ul>
<li>Qcache_queries_in_cache:当前缓存中缓存的查询数量。 </li>
</ul>
<ul>
<li>Qcache_not_cached 未进入查询缓存的select个数</li>
</ul>
<p>缓存参数设置</p>
<ul>
<li><p>query_cache_size，缓存大小。QC存储的单位最小是1024byte，所以如果你设定的一个不是1024的倍数的值。这个值会被四舍五入到最接近当前值的等于1024的倍数的值</p>
</li>
<li><p>query_cache_limit，超出此大小的查询将不被缓存</p>
</li>
<li><p>query_cache_type：缓存类型，决定缓存什么样子的查询，注意这个值不能随便设置必须设置为数字，<strong>5.7中默认禁用QC，无法使用set命令设置，需要在my.ini中进行开启，</strong>，可选值以及说明如下：</p>
<ul>
<li> 0：OFF 相当于禁用了</li>
<li>1：ON 将缓存所有结果，除非你的select语句使用了SQL_NO_CACHE禁用了查询缓存</li>
<li>2：DENAND  则只缓存select语句中通过SQL_CACHE指定需要缓存的查询。</li>
</ul>
</li>
<li><p>query_cache_min_res_unit：缓存块的最小大小，query_cache_min_res_unit的配置是一柄双刃剑，默认是 4KB ，设置值大对大数据查询有好处，但是如果你查询的都是小数据查询，就容易造成内存碎片和浪费。</p>
<p>每个查询占用缓存的平均值=（query_cache_size - Qcache_free_memory）/ Qcache_queries_in_cache</p>
<p>查询缓存利用率：（query_cache_size - Qcache_free_memory) / query_cache_size * 100%，查询缓存利用率在25%以下的话说明query_cache_size 设置过大，可以适当减小：查询缓存利用率在80%以上而且Qcache_lowmem_prunes &gt; 50的话说明query_cache_size可能有点小，要不就是碎片太多</p>
<p>查询缓存命中率：Qcache_hits/(Qcache_hits+Qcache_inserts)*100%</p>
</li>
<li><p>sort_buffer_size，排序缓冲区</p>
<p>每个需要排序的线程分配该大小的一个缓冲区。增加这值加速ORDER BY 或 GROUP BY操作 sort_buffer_size是一个connection级的参数，在每个 connection（session）第一次需要使用这个buffer的时候，一次性分配设置的内存。sort_buffer_size并不是越大越好，由于是connection级的参数，过大的设置+高并发可能会耗尽系统的内存资源。例如：500个连接将会消耗500*sort_buffer_size(2M)=1G</p>
</li>
</ul>
<h5 id="InooDB参数设置"><a href="#InooDB参数设置" class="headerlink" title="InooDB参数设置"></a>InooDB参数设置</h5><ul>
<li><p>innodb_buffer_pool_size，缓存池大小设置</p>
<p>该值设置可参考以下三个参数</p>
<ul>
<li><p>Innodb已使用的缓存”页Page”数量</p>
<p>show global status like ‘Innodb_buffer_pool_pages_data’;</p>
</li>
<li><p>Innodb全部缓存页数量</p>
<p>show global status like ‘Innodb_buffer_pool_pages_total’;</p>
</li>
<li><p>Innodb每页的长度</p>
<p>show global status like ‘Innodb_page_size’;</p>
</li>
</ul>
<p>使用这三个参数计算页面使用率：</p>
<p>result = Innodb_buffer_pool_pages_data / Innodb_buffer_pool_pages_total * 100%；</p>
<p>val &gt; 95% 则考虑增大 innodb_buffer_pool_size， 建议使用物理内存的75%<br>val &lt; 95% 则考虑减小 innodb_buffer_pool_size， 建议设置为：Innodb_buffer_pool_pages_data * Innodb_page_size * 1.05 / (1024<em>1024</em>1024)</p>
</li>
<li><p>innodb_flush_log_at_trx_commit，在事务控制中，存在”事务区”来保证事务完整性，在事务提交以后，这些事务区的数据会写入到硬盘上，同时事务操作日志（log）也需要向硬盘中写入。这个参数就是用来控制何时写日志数据的，可以设置以下三个值</p>
<ul>
<li>0：log buffer将每秒一次地写入log file中，并且log file的flush(刷到磁盘)操作同时进行。该模式下在事务提交的时候，不会主动触发写入磁盘的操作。</li>
<li>1：每次事务提交时MySQL都会把log buffer的数据写入log file，并且flush（刷到磁盘）中去，该模式为系统默认。</li>
<li>2：每次事务提交时MySQL都会把log buffer的数据写入log file，但是flush（刷到磁盘）操作并不会同时进行。该模式下，MySQL会每秒执行一次 flush（刷到磁盘）操作。</li>
</ul>
<p>优劣性比较</p>
<ul>
<li>当设置为0，该模式速度最快，但不太安全，mysqld进程的崩溃会导致上一秒钟所有事务数据的丢失。</li>
<li>当设置为1，该模式是最安全的，但也是最慢的一种方式。在mysqld 服务崩溃或者服务器主机crash的情况下，binary log 只有可能丢失最多一个语句或者一个事务。。</li>
<li>当设置为2，该模式速度较快，也比0安全，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失。</li>
<li>实际测试发现，该值对插入数据的速度影响非常大，设置为2时插入10000条记录只需要两秒，设置为0时只需要一秒，设置为1时，则需要229秒。因此，MySQL手册也建议尽量将插入操作合并成一个事务，这样可以大幅度提高速度。</li>
</ul>
</li>
<li><p>innodb_doublewrite，双写操作，同一份数据写入两次，保证数据存在一个副本，预防数据因为介质问题产生丢失，默认开启</p>
</li>
<li><p>innodb_file_per_table，表空间存储模式</p>
<ul>
<li>0，使用统一的系统表空间</li>
<li>1，使用独立的表空间</li>
</ul>
</li>
<li><p>innodb_thread_concurrency，设置innodb线程的并发数，默认值为0表示不被限制，若要设置则与服务器的CPU核心数相同或是CPU的核心数的2倍。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://everyseptember.github.io/2019/07/24/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL-%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/" data-id="ckp7o8tj4001110mw3iq4edm3" data-title="MySQL调优-参数配置" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/" rel="tag">参数配置</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-数据库-MySQL-分库分表" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/07/23/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" class="article-date">
  <time class="dt-published" datetime="2019-07-23T13:55:13.000Z" itemprop="datePublished">2019-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/07/23/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/">MySQL调优-分库分表</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h4><p>分区表就是把大表按条件单独存储到不同的<code>物理小表</code>中，在构建出的完整<code>逻辑表</code></p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>更少的数据检索范围</li>
<li>拆分超级大的表，将部分数据加载至内存</li>
<li>分区表的数据更容易维护</li>
<li>分区表数据文件可以分布在不同的硬盘上，并发IO</li>
<li>减少锁的范围，避免大表锁表</li>
<li>可独立备份、恢复分区数据</li>
</ul>
<h5 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h5><p><code>create table () partition by func(字段) (partition 分区名 values 分区条件...)</code> </p>
<h5 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h5><ul>
<li>查询必须包含分区列，不允许对分区列进行计算</li>
</ul>
<ol start="2">
<li>分区列必须是数字类型</li>
<li>分区表不支持建立外键索引</li>
<li>建表时主键必须包含所有的列（影响主键索引性能）</li>
<li>最多1024个分区</li>
</ol>
<h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><h4 id="数据分库"><a href="#数据分库" class="headerlink" title="数据分库"></a>数据分库</h4><p>将数据存放在多条MySQL服务器上</p>
<p>缺点：数据分布不均匀，未能根本解决海量数据存储问题</p>
<h4 id="数据分表"><a href="#数据分表" class="headerlink" title="数据分表"></a>数据分表</h4><p>将大表按照一定规则拆分成多个表，操作时对多表分别操作并进行合并</p>
<h4 id="分库分表中间件（Sharding-Sphere）"><a href="#分库分表中间件（Sharding-Sphere）" class="headerlink" title="分库分表中间件（Sharding Sphere）"></a>分库分表中间件（Sharding Sphere）</h4><p>结构</p>
<p><img src="https://s2.ax1x.com/2019/07/24/eESkB6.png" alt="Sharding Sphere结构"></p>
<h5 id="Sharding-JDBC"><a href="#Sharding-JDBC" class="headerlink" title="Sharding JDBC"></a>Sharding JDBC</h5><ul>
<li>定位为轻量级Java框架，在Java的JDBC层提供的额外服务</li>
<li>它使用客户端直接连接数据库，以jar包形式提供服务</li>
<li>可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架（mybatis、hibernate等）</li>
</ul>
<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>applicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sharding:data-source</span> <span class="attr">id</span>=<span class="string">&quot;shardingDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            sharding:sharding-rule定义分表规则:</span></span><br><span class="line"><span class="comment">            data-source-names=&quot;ds0,ds1&quot; 说明有几个数据源</span></span><br><span class="line"><span class="comment">            sharding:table-rule 节点定义数据存储规则</span></span><br><span class="line"><span class="comment">            logic-table=&quot;t_order&quot; 代表逻辑表名</span></span><br><span class="line"><span class="comment">            actual-data-nodes=&quot;ds$-&gt;&#123;0..1&#125;.t_order_$-&gt;&#123;0..1&#125;&quot;</span></span><br><span class="line"><span class="comment">            说明数据分布在ds0与ds1两个数据源,物理表存在t_order_0与t_order_1</span></span><br><span class="line"><span class="comment">            database-strategy-ref=&quot;databaseStrategy&quot; 说明order表分库策略</span></span><br><span class="line"><span class="comment">            基于order.user_id值对2取余保存到ds0或ds1的数据库中</span></span><br><span class="line"><span class="comment">            table-strategy-ref=&quot;orderTableStrategy&quot;</span></span><br><span class="line"><span class="comment">            基于order.order_id对2取余决定存储在对应数据库的 t_order_0或者t_order_1表中</span></span><br><span class="line"><span class="comment">            实例:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            insert into t_order(order_id , user_id,status) values( ? , ? , &#x27;N&#x27;)</span></span><br><span class="line"><span class="comment">            order_id  user_id</span></span><br><span class="line"><span class="comment">            1         2           -&gt; ds0.order_1</span></span><br><span class="line"><span class="comment">            2         2           -&gt; ds0.order_0</span></span><br><span class="line"><span class="comment">            3         1           -&gt; ds1.order_1</span></span><br><span class="line"><span class="comment">            4         1           -&gt; ds1.order_0</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">	...        </span><br><span class="line"><span class="tag">&lt;/<span class="name">sharding:data-source</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="分布式主键"><a href="#分布式主键" class="headerlink" title="分布式主键"></a>分布式主键</h5><p>在分库分表后，不要使用数据库自动生成主键，需采用<a target="_blank" rel="noopener" href="https://shardingsphere.apache.org/document/current/cn/features/sharding/other-features/key-generator/">分布式主键</a>生成策略</p>
<h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4><ol>
<li><p>配置主从数据库</p>
</li>
<li><p>配置applicationContext.xml中Sharding Sphere的读写分离</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    定义ShardingJDBC主从分离(读写)数据源</span></span><br><span class="line"><span class="comment">    ds0是主服务器,用于写入操作</span></span><br><span class="line"><span class="comment">    ds1是从属服务器,用于读取操作</span></span><br><span class="line"><span class="comment">    其中,ds0也承担一部分查询职责.(生产环境不建议这样做)</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">master-slave:data-source</span> <span class="attr">id</span>=<span class="string">&quot;msDataSouce&quot;</span></span></span><br><span class="line"><span class="tag">                          <span class="attr">master-data-source-name</span>=<span class="string">&quot;ds0&quot;</span></span></span><br><span class="line"><span class="tag">                          <span class="attr">slave-data-source-names</span>=<span class="string">&quot;ds0,ds1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">master-slave:props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;sql.show&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">master-slave:props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">master-slave:data-source</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="一主多从数据同步"><a href="#一主多从数据同步" class="headerlink" title="一主多从数据同步"></a>一主多从数据同步</h3><p>不同服务器上数据的完全同步</p>
<p>原理：从服务器从主服务器上读取操作日志，并执行其中的SQL语句</p>
<ol>
<li><p>修改主从服务器的my.ini文件</p>
<ul>
<li>server-id不能相同</li>
</ul>
</li>
<li><p>在主服务器上为从属服务器创建用户，并赋予其权限</p>
</li>
<li><p>查询主服务器日志状态</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> master status</span><br></pre></td></tr></table></figure></li>
<li><p>在从属服务器上执行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER <span class="keyword">TO</span> </span><br><span class="line">MASTER_HOST<span class="operator">=</span><span class="string">&#x27;主服务器IP&#x27;</span>,</span><br><span class="line">MASTER_PORT<span class="operator">=</span>主服务器端口,</span><br><span class="line">MASTER_USER<span class="operator">=</span><span class="string">&#x27;主服务器开放用户&#x27;</span>,</span><br><span class="line">MASTER_PASSWORD<span class="operator">=</span><span class="string">&#x27;主服务器开放用户密码&#x27;</span>,</span><br><span class="line">MASTER_LOG_FILE<span class="operator">=</span><span class="string">&#x27;主服务器日志文件&#x27;</span>,</span><br><span class="line">MASTER_LOG_POS<span class="operator">=</span>主服务器查询到的最后位置;</span><br></pre></td></tr></table></figure></li>
<li><p>从属服务器开始执行主从复制</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> slave</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://everyseptember.github.io/2019/07/23/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" data-id="ckp7o8tj3000z10mw9vb73iv0" data-title="MySQL调优-分库分表" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" rel="tag">分库分表</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-数据库-MySQL-工具" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/06/09/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL-%E5%B7%A5%E5%85%B7/" class="article-date">
  <time class="dt-published" datetime="2019-06-09T07:00:11.000Z" itemprop="datePublished">2019-06-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/06/09/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL-%E5%B7%A5%E5%85%B7/">MySQL调优-工具</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="慢SQL日志"><a href="#慢SQL日志" class="headerlink" title="慢SQL日志"></a>慢SQL日志</h3><ul>
<li><p>开启慢SQL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global slow_query_log = on;</span><br></pre></td></tr></table></figure></li>
<li><p>设置慢SQL执行时间阈值，以秒为单位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global long_query_time = 0.001;</span><br></pre></td></tr></table></figure></li>
<li><p>指定慢SQL日志文件文件，目录保存在mysql/data下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global slow_query_file = &quot;文件名&quot;;</span><br></pre></td></tr></table></figure></li>
<li><p>是否记录没有使用索引的SQL语句（系统表查询也会被记录，冗余数据无法排出 ）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global log_queries_not_using_indexes = on;</span><br></pre></td></tr></table></figure></li>
<li><p>永久生效可将上述语句保存在my.cnf配置文件中</p>
</li>
</ul>
<h3 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h3><p>使用explain关键字加SQL语句；</p>
<h4 id="执行计划列含义"><a href="#执行计划列含义" class="headerlink" title="执行计划列含义"></a>执行计划列含义</h4><ul>
<li><p>id列，编号是 select 的序列号，有几个 select 就有几个id，并且id的顺序是按 select 出现的顺序增长的。当多表关联时，id=1的表是驱动表</p>
</li>
<li><p><strong>select type</strong>列，查询类型,说明查询的种类</p>
<ul>
<li>simple：简单查询。查询不包含子查询和union</li>
<li>primary：复杂查询中最外层的 select</li>
<li>derived：包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表（derived的英文含义）</li>
<li>union：在 union 中的第二个和随后的 select，union操作会产生union result，其结果使用临时表存储的，没有索引，应尽量减少使用</li>
<li>union result：从 union 临时表检索结果的 select</li>
<li>subquery：包含在 select 中的子查询（不在 from 子句中）</li>
</ul>
</li>
<li><p>table列，表示执行计划的当前行正在访问哪个表</p>
</li>
<li><p>partitions列，说明查询作用在哪个分区表上</p>
</li>
<li><p><strong>type</strong>列，这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行。type包含以下12种值，其效率依次递减（加粗为常用类型）</p>
<ol>
<li><p>system</p>
</li>
<li><p><strong>const</strong>，mysql能对查询的某部分进行优化并将其转化成一个常量。用于 primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。</p>
<p><code>explain select * from (select * from film where id = 1) tmp;</code></p>
</li>
<li><p><strong>eq_ref</strong>，primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。这可能是在 const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。（多出现于多表关联时）</p>
<p><code>explain select * from film_actor left join film on film_actor.film_id = film.id;</code></p>
</li>
<li><p><strong>ref</strong>，相比eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行</p>
<p><code>explain select * from film where name = &quot;film1&quot;;</code></p>
</li>
<li><p>fulltext，全文索引</p>
</li>
<li><p><strong>ref_or_null</strong>，类似ref，但是可以搜索值为NULL的行</p>
<p><code>explain select * from film where name = &quot;film1&quot; or name is null;</code></p>
</li>
<li><p>index_merge</p>
</li>
<li><p>unique_subquery</p>
</li>
<li><p>index_subquery</p>
</li>
<li><p><strong>range</strong>，范围扫描，通常出现在 in(), between ,&gt; ,&lt;, &gt;= 等操作中。使用一个索引来检索给定范围的行</p>
</li>
<li><p><strong>index</strong>，和ALL一样，不同就是mysql只需扫描索引树，这通常比ALL快一些</p>
<p><code>explain select count(*) from film;</code></p>
</li>
<li><p><strong>ALL</strong>，即全表扫描，意味着mysql需要从头到尾去查找所需要的行。通常情况下这需要增加索引来进行优化了</p>
<p><code>explain select * from actor;</code></p>
</li>
</ol>
</li>
<li><p>possible_keys列，这一列显示查询可能使用哪些索引来查找</p>
</li>
<li><p>key列，这一列显示mysql实际采用哪个索引来优化对该表的访问</p>
</li>
<li><p>key_len列，这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列</p>
</li>
<li><p>ref列，这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），func，NULL，字段名（例：film.id）</p>
</li>
<li><p>row列，这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数</p>
</li>
<li><p>filtered列，是一个百分比的值，代表 (rows * filtered) / 100，这个结果将于前表产生交互，是一个预估值</p>
</li>
<li><p>Extra列，这一列展示的是额外信息，以下是可能产生的信息</p>
<ul>
<li><p>distinct：一旦mysql找到了与行相联合匹配的行，就不再搜索了</p>
<p><code>explain select distinct name from film left join film_actor on film.id = film_actor.film_id;</code></p>
</li>
<li><p><strong>Using index</strong>：这发生在对表的请求列都是同一索引的部分的时候，返回的列数据只使用了索引中的信息，而没有再去访问表中的行记录。是性能高的表现。也叫做索引覆盖。</p>
<p><code>explain select id,name from film order by id;</code></p>
</li>
<li><p>Using where：mysql服务器将在存储引擎检索行后再进行过滤。就是先读取整行数据，再按 where 条件进行检查，符合就留下，不符合就丢弃。</p>
<p><code>explain select * from film where id &gt; 1;</code></p>
</li>
<li><p>using temporary：mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化</p>
<p><code>explain select distinct name from actor;（name字段无索引时）</code></p>
</li>
<li><p>using filesort：采用文件扫描对结果进行计算排序，效率很差</p>
<p>对于排序，只有select字段与order by字段都被索引覆盖是才允许使用Using Index</p>
<p><code>explain select name from actor order by name;（name字段需要有索引）</code></p>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://everyseptember.github.io/2019/06/09/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL-%E5%B7%A5%E5%85%B7/" data-id="ckp7o8tjb001710mw7b2jf83s" data-title="MySQL调优-工具" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%85%A2SQL%E6%97%A5%E5%BF%97/" rel="tag">慢SQL日志</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/" rel="tag">执行计划</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-数据库-MySQL-索引" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/05/29/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL-%E7%B4%A2%E5%BC%95/" class="article-date">
  <time class="dt-published" datetime="2019-05-29T10:48:17.000Z" itemprop="datePublished">2019-05-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/05/29/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL-%E7%B4%A2%E5%BC%95/">MySQL调优-索引</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引是为表建立的快速访问的目录，避免全表扫描，MySQL中索引的存储形式是根据存储引擎决定的</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li>根据存储结构<ul>
<li>BTree索引（B-Tree索引或者B+Tree索引）</li>
<li>Hash索引</li>
<li>full-index索引</li>
<li>R-Tree索引</li>
</ul>
</li>
<li>根据应用层次<ul>
<li>普通索引</li>
<li>唯一索引（效率最高）</li>
<li>复合索引</li>
</ul>
</li>
<li>根据物理顺序与键值的逻辑顺序关系<ul>
<li>聚集索引</li>
<li>非聚集索引</li>
</ul>
</li>
</ul>
<h4 id="MySQL中常用的索引"><a href="#MySQL中常用的索引" class="headerlink" title="MySQL中常用的索引"></a>MySQL中常用的索引</h4><ul>
<li>B+Tree索引 - 适用于范围查找</li>
<li>Hash索引 - 适用于精准查找</li>
</ul>
<h4 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h4><p>MySQL中InnoDB与MyISAM采用的索引</p>
<p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g3o5omzqquj30ic09u0te.jpg" alt="B+Tree"></p>
<ul>
<li>InnoDB<ul>
<li>B+Tree采用树形链表结构建立数据目录</li>
<li>B+Tree索引是一种聚集索引</li>
<li>索引底层节点之间持有一个单项链表，更适合范围查找</li>
<li>在其他字段上建立的索引会主动关联主键索引，然后根据主键去寻找数据</li>
</ul>
</li>
<li>MyISAM<ul>
<li>B+Tree在MyISAM中是一种非聚集索引</li>
</ul>
</li>
</ul>
<p>其他：B-Tree同样是一棵树，但在底层节点之间没有联系，不适合范围查询</p>
<p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g3o5nwdaakj30fr09daai.jpg" alt="B-Tree"></p>
<h5 id="解释计划"><a href="#解释计划" class="headerlink" title="解释计划"></a>解释计划</h5><p>使用explain+SQL语句，便可查看语句的执行情况，根据解释计划可对该SQL进行针对性的优化</p>
<h5 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h5><ul>
<li>精确匹配与范围匹配都可以使用索引</li>
<li>模糊匹配（like）时前缀查询可以使用索引，效率与前缀筛选粒度有关</li>
<li>模糊匹配（like）时后缀查询不会使用索引，进行全表扫描</li>
<li>复合索引<ul>
<li>复合索引需要讲选择性高的索引放到左侧</li>
<li>在使用复合索引的时候一定要包含左侧列，单使用右侧列不会使用索引</li>
</ul>
</li>
<li>&lt;&gt; 与 not in 不会使用索引<ul>
<li>对数字可使用大于或者小于的场景进行优化</li>
</ul>
</li>
<li>查询范围太大也不会用索引</li>
</ul>
<h4 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h4><ul>
<li>基于哈希表实现</li>
<li>只有使用精准匹配所有列的时候才有效</li>
<li>为每一条数据创建哈希值，基于哈希值进行匹配查询</li>
<li>当前MySQL只有memory引擎才支持显式hash索引<ul>
<li>Memory支持在创建表时对列创建hash所以你能</li>
</ul>
</li>
</ul>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li>Hash索引只包含哈希值和行指针</li>
<li>只支持精准匹配，不支持范围查询、模糊查询及排序</li>
<li>Hash取值非常快，但索引选择性很低时不建议使用</li>
</ul>
<h5 id="InnoDB中的hash索引"><a href="#InnoDB中的hash索引" class="headerlink" title="InnoDB中的hash索引"></a>InnoDB中的hash索引</h5><ul>
<li><p>InnoDB存储引擎只支持显式创建BTree索引</p>
</li>
<li><p>InnoDB精准匹配时会自动生成HashCode，存入缓存</p>
</li>
</ul>
<h4 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h4><ul>
<li>优点<ul>
<li>大幅提高了数据的检索效率</li>
<li>BTree等聚集索引将随机IO整理成顺序IO，提高范围查询效率</li>
</ul>
</li>
<li>缺点<ul>
<li>降低了写入数据的效率</li>
<li>太多的索引增加了查询优化器的选择时间</li>
<li>不合理的使用索引，会大幅占用磁盘空间</li>
</ul>
</li>
</ul>
<h4 id="索引的优化"><a href="#索引的优化" class="headerlink" title="索引的优化"></a>索引的优化</h4><p>不会使用索引的情况</p>
<ul>
<li>索引选择性太差</li>
<li>&lt;&gt;或not in或is not null</li>
<li>where子句跳过复合索引左侧索引列，直接使用右侧索引列</li>
<li>对索引列进行计算或函数处理（Oracle支持函数索引）的情况</li>
</ul>
<p>对索引的分析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	object_type,		#对象类型</span><br><span class="line">	object_schema,		#所属数据库</span><br><span class="line">	object_name,		#对象名称</span><br><span class="line">	index_name,			#索引名</span><br><span class="line">	count_read,			#索引在计算过程中读取行数</span><br><span class="line">	count_fetch,		#索引查询结果行数</span><br><span class="line">	count_insert,		#通过索引进行新增操作的行数</span><br><span class="line">	count_update,		#通过索引进行新增更新的行数</span><br><span class="line">	count_delete 		#通过索引进行新增删除的行数</span><br><span class="line">FROM</span><br><span class="line">	performance_schema.table_io_waits_summary_by_index_usage </span><br><span class="line">ORDER BY</span><br><span class="line">	sum_timer_wait DESC;</span><br></pre></td></tr></table></figure>

<p>最后五列代表使用次数，当上线一段时间后，可用该语句进行分析，大部分使用次数都是0的索引可以删除。</p>
<h4 id="使用索引优化排序"><a href="#使用索引优化排序" class="headerlink" title="使用索引优化排序"></a>使用索引优化排序</h4><p>当order by字段与索引字段顺序、排序方向相同时，才可使用索引优化排序速度</p>
<ul>
<li>当单字段使用索引时，升降序不会影响速度</li>
<li>当使用多列索引时，必须是升序，且顺序不允许打乱</li>
</ul>
<h4 id="减少表与索引碎片"><a href="#减少表与索引碎片" class="headerlink" title="减少表与索引碎片"></a>减少表与索引碎片</h4><ul>
<li>analyze table 表名<ul>
<li>对索引的统计信息进行重新计算</li>
</ul>
</li>
<li>optimize table 表名<ul>
<li>对表数据进行优化、重新组织</li>
</ul>
</li>
</ul>
<h4 id="嵌套循环关联（Nested-Loop-Join）"><a href="#嵌套循环关联（Nested-Loop-Join）" class="headerlink" title="嵌套循环关联（Nested Loop Join）"></a>嵌套循环关联（Nested Loop Join）</h4><p>MySQL中的执行流程</p>
<ul>
<li>选择驱动表（MySQL执行）<ul>
<li>对SQL语句进行解释计划分析时，第一行出现的表就是驱动表</li>
</ul>
</li>
<li>对驱动表进行检索</li>
<li>根据驱动表结果循环对关联表进行检索</li>
<li>输出结果</li>
</ul>
<p>对关联查询的优化</p>
<ul>
<li>判断驱动表，对驱动表加索引</li>
<li>对关联表外键添加索引</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://everyseptember.github.io/2019/05/29/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL-%E7%B4%A2%E5%BC%95/" data-id="ckp7o8tjc001910mw6xkp7v5m" data-title="MySQL调优-索引" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-数据库-MySQL-存储引擎" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/05/26/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" class="article-date">
  <time class="dt-published" datetime="2019-05-26T08:10:37.000Z" itemprop="datePublished">2019-05-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/05/26/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/">MySQL调优-存储引擎</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h3><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g3esol5eb5j30jc0dwwhd.jpg" alt="MySQL体系结构"></p>
<h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>存储引擎只针对表，每个表只允许有一个存储引擎，数据库中允许出现多个不同引擎</p>
<p>常见的有InnoDB、MyISAM、Memory等</p>
<p>创建表时选择引擎：<code>CREATE TABLE 表名() ENGINE 引擎名;</code></p>
<h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><ol>
<li>MySQL5.5.8后默认的存储引擎</li>
<li>InnoDB采用“表空间”保存文件</li>
<li>InnoDB支持事务处理</li>
</ol>
<h5 id="存储特性"><a href="#存储特性" class="headerlink" title="存储特性"></a>存储特性</h5><ul>
<li>表空间的两种形式<ul>
<li>早期使用系统表空间ibdata1（ibdataN）中，所有数据放到一个文件中</li>
<li>5.6之后默认使用独立表空间：表明.ibd（推荐）</li>
</ul>
</li>
<li>设置innodb_file_per_table修改表空间模式</li>
<li>支持部分的内存存储</li>
</ul>
<h5 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h5><ul>
<li>InnoDB支持事务</li>
<li>InnoDB默认使用行级锁</li>
<li>InnoDB具有良好的高并发特性</li>
</ul>
<h6 id="MySQL的锁"><a href="#MySQL的锁" class="headerlink" title="MySQL的锁"></a>MySQL的锁</h6><ul>
<li>职责分类<ul>
<li>共享锁-读锁</li>
<li>独占锁（排它锁）-写锁</li>
</ul>
</li>
<li>粒度分类<ul>
<li>行级锁</li>
<li>表级锁（包括读取同样被锁）</li>
</ul>
</li>
</ul>
<p>InnoDB中只有利用索引的写操作才是行级锁，不能使用索引的写操作时表级锁</p>
<h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul>
<li>MySQL5.7开始有InnoDB支持全文索引与空间函数</li>
<li>优先推荐使用</li>
</ul>
<h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><ul>
<li>不支持事务</li>
<li>支持全文检索，支持text支持前缀索引</li>
<li>支持数据压缩</li>
<li>紧密存储，顺序读性能良好</li>
<li>表级锁，混合读写性能不加，并发性差</li>
</ul>
<h6 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h6><ul>
<li>非事务应用，如保存日志</li>
<li>只读类应用，如报表数据、字典数据</li>
<li>空间类应用（5.7之前）</li>
<li>MySQL自动创建的系统临时表，SQL查询，分组的临时表引擎</li>
</ul>
<h4 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h4><ul>
<li>不支持事务</li>
<li>内存读写，临时存储</li>
<li>超高的读写效率，比MyISAM高一个量级</li>
<li>表级锁，并发性差</li>
</ul>
<h6 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h6><ul>
<li>读多写少的静态数据</li>
<li>充当缓存使用，保存高频访问静态数据</li>
<li>MySQL自动创建的系统临时表</li>
</ul>
<h6 id="关键参数"><a href="#关键参数" class="headerlink" title="关键参数"></a>关键参数</h6><ul>
<li>max_heap_table_size：控制内存表大小（字节）<ul>
<li>默认16m</li>
</ul>
</li>
<li>tmp_table_size：设置内存临时表最大值（字节）</li>
</ul>
<h4 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h4><ul>
<li>纯文本保存</li>
<li>不支持事务</li>
<li>不支持索引</li>
<li>不允许空列</li>
</ul>
<h6 id="适用场景-3"><a href="#适用场景-3" class="headerlink" title="适用场景"></a>适用场景</h6><ul>
<li>数据交换/数据迁移</li>
<li>不依赖MySQL环境</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://everyseptember.github.io/2019/05/26/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" data-id="ckp7o8tj9001510mwb7mpbfuq" data-title="MySQL调优-存储引擎" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" rel="tag">MySQL存储引擎</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-数据库-MySQL-基础知识" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/05/26/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="article-date">
  <time class="dt-published" datetime="2019-05-26T07:10:13.000Z" itemprop="datePublished">2019-05-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/05/26/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">MySQL调优-基础知识</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="影响MySQL性能的主要因素"><a href="#影响MySQL性能的主要因素" class="headerlink" title="影响MySQL性能的主要因素"></a>影响MySQL性能的主要因素</h3><ul>
<li>数据库结构设计</li>
<li>数据库存储引擎</li>
<li>SQL语句的书写</li>
<li>数据库参数配置</li>
<li>服务器系统和硬件</li>
</ul>
<h3 id="数据库结构设计"><a href="#数据库结构设计" class="headerlink" title="数据库结构设计"></a>数据库结构设计</h3><h4 id="三范式"><a href="#三范式" class="headerlink" title="三范式"></a>三范式</h4><ol>
<li>数据库中每个字段只包含一个独立且不可拆分的属性</li>
<li>满足第一范式，必须有一个主键，且其他字段必须与主键有关系</li>
<li>满足第二范式，所有字段与主键直接相关，而不是间接相关</li>
</ol>
<h5 id="反范式设计"><a href="#反范式设计" class="headerlink" title="反范式设计"></a>反范式设计</h5><p>表设计不一定完全按照范式进行设计，在特定情况下可根据业务需求进行一些反范式的设计。</p>
<h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><ol>
<li>单表查询易于优化，益于管理</li>
<li>SQL语句简单，有利于程序开发</li>
</ol>
<h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><ol>
<li>存在数据冗余，写操作时需要额外更新从表数据</li>
<li>不合理的反范式设计会让表变得臃肿</li>
</ol>
<h4 id="实体关系分析"><a href="#实体关系分析" class="headerlink" title="实体关系分析"></a>实体关系分析</h4><ul>
<li>实体关系是指系统事物之间的联系</li>
<li>实体关系需要双向分析</li>
<li>实体关系决定表关系</li>
</ul>
<h5 id="表关系设计原则"><a href="#表关系设计原则" class="headerlink" title="表关系设计原则"></a>表关系设计原则</h5><ul>
<li>一对一，通过主键关联</li>
<li>一对多，在多的一方设置外键</li>
<li>多对多，增加中间表，持有双方外键</li>
</ul>
<h4 id="自然主键与代理主键"><a href="#自然主键与代理主键" class="headerlink" title="自然主键与代理主键"></a>自然主键与代理主键</h4><ul>
<li>自然主键是指事务属性中的自然唯一标示</li>
<li>代理主键是指与业务无关的，无意义的数字序列值</li>
<li>表设计时，优先推荐代理主键，不推荐自然主键</li>
</ul>
<h4 id="数据类型的选择"><a href="#数据类型的选择" class="headerlink" title="数据类型的选择"></a>数据类型的选择</h4><h5 id="字段类型优先级"><a href="#字段类型优先级" class="headerlink" title="字段类型优先级"></a>字段类型优先级</h5><ol>
<li>数字类型</li>
<li>日期类型与二进制类型</li>
<li>字符串类型</li>
</ol>
<h5 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h5><table>
<thead>
<tr>
<th>列类型</th>
<th>存储空间</th>
<th>SIGNED</th>
<th>UNSIGNED</th>
</tr>
</thead>
<tbody><tr>
<td>tinyint</td>
<td>1字节</td>
<td>-128 ~ 127</td>
<td>0 ~ 255</td>
</tr>
<tr>
<td>smallint</td>
<td>2字节</td>
<td>-32768 ~ 32767</td>
<td>0 ~ 65536</td>
</tr>
<tr>
<td>mediumint</td>
<td>3字节</td>
<td>-8388608 ~ 8388607</td>
<td>0 ~ 16777215</td>
</tr>
<tr>
<td>int</td>
<td>4字节</td>
<td>-2147483648 ~ 2147483647</td>
<td>0 ~ 4294967295</td>
</tr>
<tr>
<td>bigint</td>
<td>8字节</td>
<td>-9223372036854775808 ~ 9223372036854775807</td>
<td>0 ~ 18446744073709551615</td>
</tr>
</tbody></table>
<h5 id="实数类型"><a href="#实数类型" class="headerlink" title="实数类型"></a>实数类型</h5><table>
<thead>
<tr>
<th>列类型</th>
<th>存储空间</th>
<th>是否精确类型</th>
</tr>
</thead>
<tbody><tr>
<td>FLOAT</td>
<td>4字节</td>
<td>否</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>8字节</td>
<td>否</td>
</tr>
<tr>
<td>DECIMAL</td>
<td>每4个字节存9个数字，小数点占一个字节</td>
<td>是</td>
</tr>
</tbody></table>
<p>财务数据一定要使用DECIMAL</p>
<h5 id="VARCHAR类型"><a href="#VARCHAR类型" class="headerlink" title="VARCHAR类型"></a>VARCHAR类型</h5><p>VARCHAR表示变体长度，根据实际内容保存数据</p>
<ol>
<li>尽量使用最小的符合需求的长度</li>
<li>VARCHAR(255)以下使用额外一个字节保存实际内容长度，VARCHAR(255)以上额外使用两个字节保存实际内容长度；所以255是一个常见的长度分水岭</li>
<li>虽然在磁盘存储的角度上，VARCHAR(5)与VARCHAR(200)实际存储内容长度可能相同，但内存占用不同，长度越长需要占用的内存越多</li>
<li>VARCHAR变更长度时会出现锁表</li>
</ol>
<h6 id="VARCHAR的适用场景"><a href="#VARCHAR的适用场景" class="headerlink" title="VARCHAR的适用场景"></a>VARCHAR的适用场景</h6><ul>
<li>VARCHAR适合存储长度波动大的数据（如博客文章）</li>
<li>字符串很少被更新的场景</li>
<li>VARCHAR适合保存多字节字符</li>
</ul>
<h5 id="CHAR类型"><a href="#CHAR类型" class="headerlink" title="CHAR类型"></a>CHAR类型</h5><ul>
<li>CHAR属于定长数据</li>
<li>CHAR最大长度255</li>
<li>CHAR类型会自动删除末尾的空格</li>
<li>CHAR类型检索效率比VARCHAR高</li>
</ul>
<h6 id="CHAR的适用场景"><a href="#CHAR的适用场景" class="headerlink" title="CHAR的适用场景"></a>CHAR的适用场景</h6><ul>
<li>CHAR适合存储长度波动不大的数据，如MD5</li>
<li>CHAR适合存储短字符串</li>
<li>CHAR适合存储经常更新的字符串</li>
</ul>
<h5 id="DATETIME类型"><a href="#DATETIME类型" class="headerlink" title="DATETIME类型"></a>DATETIME类型</h5><ul>
<li>占用8个字节</li>
<li>与时区无关</li>
<li>可保存到毫秒</li>
<li>可保存时间范围大</li>
</ul>
<h5 id="TIMESTAMP时间戳类型"><a href="#TIMESTAMP时间戳类型" class="headerlink" title="TIMESTAMP时间戳类型"></a>TIMESTAMP时间戳类型</h5><ul>
<li>占用4个字节</li>
<li>时间范围：1970-01-01到2038-01-19</li>
<li>精确到秒</li>
<li>采用整型存储</li>
<li>依赖于时区</li>
<li>自动更新timestamp列值</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://everyseptember.github.io/2019/05/26/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" data-id="ckp7o8tj8001410mwh7uzgnbj" data-title="MySQL调优-基础知识" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL%E5%9F%BA%E7%A1%80/" rel="tag">MySQL基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-数据结构-非线性表-堆" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A1%A8-%E5%A0%86/" class="article-date">
  <time class="dt-published" datetime="2019-05-05T12:03:48.000Z" itemprop="datePublished">2019-05-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A1%A8-%E5%A0%86/">数据结构-非线性表-堆</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>完全二叉树</li>
<li>每一个节点的的值都必须大于等于（或小于等于）其子树中的每个节点的值</li>
</ul>
<p>每个节点都大于等于子树节点的堆，叫做<strong>大顶堆</strong>；反之叫做<strong>小顶堆</strong></p>
<h2 id="操作堆"><a href="#操作堆" class="headerlink" title="操作堆"></a>操作堆</h2><h3 id="插入一个元素"><a href="#插入一个元素" class="headerlink" title="插入一个元素"></a>插入一个元素</h3><p>将新数据放到堆顶或者最后，然后调整该节点的位置，该过程称为<strong>堆化</strong></p>
<h4 id="堆化"><a href="#堆化" class="headerlink" title="堆化"></a>堆化</h4><p>将新插入的元素与其父节点比较大小，如果是大顶堆且新节点值大于父节点（小顶堆则判断是否小于父节点的值），则交换两个节点值，依次向上，直到符合堆定义。</p>
<h3 id="删除堆顶元素"><a href="#删除堆顶元素" class="headerlink" title="删除堆顶元素"></a>删除堆顶元素</h3><p>将堆顶元素删除，然后将数组末位数字放到堆顶，然后自上而下堆化</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h3><p>首先将数据以堆的形式进行存储</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buidHeap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(a, i, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxPos = i;</span><br><span class="line">        <span class="keyword">if</span> (i * <span class="number">2</span> &lt;= n &amp;&amp; a[i * <span class="number">2</span>] &gt; a[maxPos]) &#123;</span><br><span class="line">            maxPos = i * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i * <span class="number">2</span> + <span class="number">1</span> &lt;= n &amp;&amp; a[i * <span class="number">2</span> + <span class="number">1</span>] &gt; a[maxPos]) &#123;</span><br><span class="line">            maxPos = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxPos == i) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        a[i] = a[maxPos];</span><br><span class="line">        a[maxPos] = temp;</span><br><span class="line">        i = maxPos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>首先建堆，然后将堆顶元素与最后一个元素进行交换，再将其他元素再次堆化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length - <span class="number">1</span>;</span><br><span class="line">    buidHeap(a, n);</span><br><span class="line">    <span class="keyword">int</span> k = n;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[<span class="number">1</span>];</span><br><span class="line">        a[<span class="number">1</span>] = a[k];</span><br><span class="line">        a[k] = temp;</span><br><span class="line">        heapify(a, <span class="number">1</span>, --k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://everyseptember.github.io/2019/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A1%A8-%E5%A0%86/" data-id="ckp7o8tjm001l10mw1rx4amzx" data-title="数据结构-非线性表-堆" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A0%86/" rel="tag">堆</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A0%91/" rel="tag">树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A1%A8/" rel="tag">非线性表</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-数据结构-非线性表-红黑树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A1%A8-%E7%BA%A2%E9%BB%91%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2019-04-17T11:14:49.000Z" itemprop="datePublished">2019-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A1%A8-%E7%BA%A2%E9%BB%91%E6%A0%91/">数据结构-非线性表-红黑树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="平衡二叉查找树"><a href="#平衡二叉查找树" class="headerlink" title="平衡二叉查找树"></a>平衡二叉查找树</h3><h5 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h5><p>二叉树中任意一个节点的左右子树的高度相差不能大于1</p>
<p>所以满二叉树、完全二叉树都是平衡二叉树，但非完全二叉树也可能是平衡二叉树</p>
<h5 id="平衡二叉查找树-1"><a href="#平衡二叉查找树-1" class="headerlink" title="平衡二叉查找树"></a>平衡二叉查找树</h5><p>在满足平衡二叉树的同时，还满足二叉查找树的特点</p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树是一种不严格的平衡二叉查找树，它的各个叶子节点的深度可能相差一倍</p>
<p>红黑树中的节点，一类被标记为黑色，一类被标记为红色，同时还要满足以下几个要求：</p>
<ul>
<li>根节点是黑色的</li>
<li>每个叶子结点都是黑色的空节点（NIL），即叶子结点不存储数据（为了更简单地实现）</li>
<li>任何相邻的节点都不能同时为红色，即红色节点是被黑色节点分开的</li>
<li>每个节点，从该节点通过任何路径到达其可达叶子结点，都包含相同数量的黑色节点</li>
</ul>
<p>将红黑树种的红色节点全部取出，然后将子节点接到祖父节点上，这样会形成四叉树。由于红黑树任意节点到叶子节点都包含相同数量黑色节点的特性，形成的四叉树的所有叶子结点高度相同。将多余的节点放到叶子节点中，就会形成完全二叉树。这时其高度是log2 n，将红色节点放回其位置，由于红色节点不相邻的特性，其高度不会超过2 * log2 n，所以操作复杂度仍是<code>O(logn)</code>，性能仍然很好。</p>
<p>红黑树的插入、删除操作会破坏红黑树的平衡，需要调整平衡。</p>
<h4 id="左旋（rotate-left）、右旋（rotate-right）"><a href="#左旋（rotate-left）、右旋（rotate-right）" class="headerlink" title="左旋（rotate left）、右旋（rotate right）"></a>左旋（rotate left）、右旋（rotate right）</h4><p><img src="https://static001.geekbang.org/resource/image/0e/1e/0e37e597737012593a93105ebbf4591e.jpg" alt="左旋、右旋"></p>
<h4 id="插入平衡操作"><a href="#插入平衡操作" class="headerlink" title="插入平衡操作"></a>插入平衡操作</h4><p>红黑树规定，插入的节点必须是红色的。而且，二叉查找树中新插入的节点都是都是放在叶子结点上。</p>
<ul>
<li>如果插入节点的父节点是黑色的，直接插入即可；</li>
<li>如果插入的节点是根节点，则直接将其转成黑色；</li>
<li>除上述两种情况外的所有情况都会破坏红黑树平衡，需要进行平衡调整；</li>
</ul>
<h5 id="插入操作调整步骤"><a href="#插入操作调整步骤" class="headerlink" title="插入操作调整步骤"></a>插入操作调整步骤</h5><p>首先，当前正在处理的节点叫做关注节点，处理的节点都是红色的。</p>
<h6 id="CASE1：如果当前关注节点a的叔叔节点d是红色的"><a href="#CASE1：如果当前关注节点a的叔叔节点d是红色的" class="headerlink" title="CASE1：如果当前关注节点a的叔叔节点d是红色的"></a>CASE1：如果当前关注节点a的叔叔节点d是红色的</h6><ol>
<li><p>将关注节点a的父节点b和叔叔节点d调整为黑色</p>
</li>
<li><p>将关注节点a的祖父节点c调整为红色</p>
</li>
<li><p>将关注节点设置为a的祖父节点c</p>
</li>
<li><p>跳转到CASE2或者CASE3</p>
<p><img src="https://static001.geekbang.org/resource/image/60/40/603cf91f54b5db21bd02c6c5678ecf40.jpg" alt="CASE1"></p>
</li>
</ol>
<h6 id="CASE2：如果当前关注节点a的叔叔节点d是黑色，且关注节点a是其父节点b的右子节点"><a href="#CASE2：如果当前关注节点a的叔叔节点d是黑色，且关注节点a是其父节点b的右子节点" class="headerlink" title="CASE2：如果当前关注节点a的叔叔节点d是黑色，且关注节点a是其父节点b的右子节点"></a>CASE2：如果当前关注节点a的叔叔节点d是黑色，且关注节点a是其父节点b的右子节点</h6><ol>
<li><p>将关注节点设置为当前关注节点a的父节点b</p>
</li>
<li><p>围绕节点b进行左旋</p>
</li>
<li><p>跳转到CASE3</p>
<p><img src="https://static001.geekbang.org/resource/image/44/ad/4480a314f9d83c343b8adbb28b6782ad.jpg" alt="CASE2"></p>
</li>
</ol>
<h6 id="CASE3：如果当前关注节点a的叔叔节点是黑色，且关注节点是其父节点的左子节点"><a href="#CASE3：如果当前关注节点a的叔叔节点是黑色，且关注节点是其父节点的左子节点" class="headerlink" title="CASE3：如果当前关注节点a的叔叔节点是黑色，且关注节点是其父节点的左子节点"></a>CASE3：如果当前关注节点a的叔叔节点是黑色，且关注节点是其父节点的左子节点</h6><ol>
<li><p>围绕当前关注节点a的祖父节点c进行右旋</p>
</li>
<li><p>将a的父节点b与兄弟节点c进行颜色互换</p>
</li>
<li><p>结束</p>
<p><img src="https://static001.geekbang.org/resource/image/04/12/04650d9470b1e67899f5b8b7b8e33212.jpg" alt="CASE3"></p>
</li>
</ol>
<h4 id="删除平衡操作"><a href="#删除平衡操作" class="headerlink" title="删除平衡操作"></a>删除平衡操作</h4><p>删除操作分两个步骤完成</p>
<ol>
<li>初步调整：使其满足从每个节点从其自身达到叶子结点的所有路径，都含有相同数量的黑色节点</li>
<li>二次调整：使其满足红色节点不相邻</li>
</ol>
<h5 id="初步调整"><a href="#初步调整" class="headerlink" title="初步调整"></a>初步调整</h5><h6 id="CASE1：删除的节点a只有一个子节点"><a href="#CASE1：删除的节点a只有一个子节点" class="headerlink" title="CASE1：删除的节点a只有一个子节点"></a>CASE1：删除的节点a只有一个子节点</h6><p>被删除的节点需要为黑色，其子节点为红色，这样才能保证满足红黑树的定义</p>
<ol>
<li><p>删除节点a，并将其子节点替b换到a的位置</p>
</li>
<li><p>将b的颜色改为黑色</p>
</li>
<li><p>结束调整，不需要二次调整</p>
<p><img src="https://static001.geekbang.org/resource/image/a6/c3/a6c4c347b7cbdf57662bab399ed36cc3.jpg" alt="CASE1"></p>
</li>
</ol>
<h6 id="CASE2：删除的节点a有两个非空子节点，且其后继节点即为其右子节点c"><a href="#CASE2：删除的节点a有两个非空子节点，且其后继节点即为其右子节点c" class="headerlink" title="CASE2：删除的节点a有两个非空子节点，且其后继节点即为其右子节点c"></a>CASE2：删除的节点a有两个非空子节点，且其后继节点即为其右子节点c</h6><ol>
<li><p>因为关注节点a的后继节点即为其右子节点c，所以节点c不会有左子树；将节点a删除，并将其右子节点c替换至节点a的位置，修改节点c为节点a的颜色</p>
</li>
<li><p>如果节点c原来的颜色为黑色，则不满足最后一条的特性，需要将节点c的右子节点d多加一个黑色，即“红黑”或者“黑黑”</p>
</li>
<li><p>将关注节点变更为节点d，在二次调整时对其进行颜色调整</p>
<p><img src="https://static001.geekbang.org/resource/image/48/4e/48e3bd2cdd66cb635f8a4df8fb8fd64e.jpg" alt="CASE2"></p>
</li>
</ol>
<h6 id="CASE3：删除的节点a有两个非空子节点，且其后继节点不是其右子节点"><a href="#CASE3：删除的节点a有两个非空子节点，且其后继节点不是其右子节点" class="headerlink" title="CASE3：删除的节点a有两个非空子节点，且其后继节点不是其右子节点"></a>CASE3：删除的节点a有两个非空子节点，且其后继节点不是其右子节点</h6><ol>
<li><p>找到节点a的后继节点d，将节点d替换至节点a，并修改其颜色与节点a相同，然后将节点d删除（删除方法参照CASE1）</p>
</li>
<li><p>如果节点d原来的颜色是黑色，则不满足最后一条的特性，需要将现节点d的右子节点c多加一个黑色，即“红黑”或者“黑黑”</p>
</li>
<li><p>将关注节点变更为节点c，在二次调整时对其进行颜色调整</p>
<p><img src="https://static001.geekbang.org/resource/image/b9/29/b93c1fa4de16aee5482424ddf49f3c29.jpg" alt="CASE3"></p>
</li>
</ol>
<h5 id="二次调整"><a href="#二次调整" class="headerlink" title="二次调整"></a>二次调整</h5><p>初步调整之后，关注节点的颜色为“红黑”或者“黑黑”</p>
<h6 id="CASE1：关注节点a的兄弟节点c颜色是红色的"><a href="#CASE1：关注节点a的兄弟节点c颜色是红色的" class="headerlink" title="CASE1：关注节点a的兄弟节点c颜色是红色的"></a>CASE1：关注节点a的兄弟节点c颜色是红色的</h6><ol>
<li><p>围绕节点a的父节点b进行左旋</p>
</li>
<li><p>关注节点a的父节点b和祖父节c点交换颜色</p>
</li>
<li><p>关注节点不变，继续从四种情况中选择合适的规则进行调整</p>
<p><img src="https://static001.geekbang.org/resource/image/ac/91/ac76d78c064a2486e2a5b4c4903acb91.jpg" alt="CASE1"></p>
</li>
</ol>
<h6 id="CASE2：关注节点a的兄弟节点c颜色是黑色的，并且节点c的左右子节点d、e都是黑色"><a href="#CASE2：关注节点a的兄弟节点c颜色是黑色的，并且节点c的左右子节点d、e都是黑色" class="headerlink" title="CASE2：关注节点a的兄弟节点c颜色是黑色的，并且节点c的左右子节点d、e都是黑色"></a>CASE2：关注节点a的兄弟节点c颜色是黑色的，并且节点c的左右子节点d、e都是黑色</h6><ol>
<li><p>将节点a的兄弟节点c变更为红色</p>
</li>
<li><p>将节点a中去掉一个黑色，此时节点a便变成了单纯的红色或者黑色</p>
</li>
<li><p>给节点a的父节点b添加一个黑色，此时节点b变成了“红黑”或者“黑黑”</p>
</li>
<li><p>关注节点变更为父节点b</p>
</li>
<li><p>继续从四种情况中进行选择</p>
<p><img src="https://static001.geekbang.org/resource/image/ec/ec/eca118d673c607eb2b103f3476fb24ec.jpg" alt="CASE2"></p>
</li>
</ol>
<h6 id="CASE3：关注节点a的兄弟节点c颜色是黑色的，并且节点c的左子节点d是红色，右子节点e是黑色的"><a href="#CASE3：关注节点a的兄弟节点c颜色是黑色的，并且节点c的左子节点d是红色，右子节点e是黑色的" class="headerlink" title="CASE3：关注节点a的兄弟节点c颜色是黑色的，并且节点c的左子节点d是红色，右子节点e是黑色的"></a>CASE3：关注节点a的兄弟节点c颜色是黑色的，并且节点c的左子节点d是红色，右子节点e是黑色的</h6><ol>
<li><p>围绕节点a的兄弟节点c右旋</p>
</li>
<li><p>节点c和节点d交换颜色</p>
</li>
<li><p>关注节点不变，跳到CASE4继续调整</p>
<p><img src="https://static001.geekbang.org/resource/image/44/af/44075213100edd70315e1492422c92af.jpg" alt="CASE3"></p>
</li>
</ol>
<h6 id="CASE4：关注节点的兄弟节点颜色是黑色的，并且兄弟节点的右子节点是红色的"><a href="#CASE4：关注节点的兄弟节点颜色是黑色的，并且兄弟节点的右子节点是红色的" class="headerlink" title="CASE4：关注节点的兄弟节点颜色是黑色的，并且兄弟节点的右子节点是红色的"></a>CASE4：关注节点的兄弟节点颜色是黑色的，并且兄弟节点的右子节点是红色的</h6><ol>
<li><p>围绕节点a父节点b左旋</p>
</li>
<li><p>将节点c的颜色设置为节点b的颜色</p>
</li>
<li><p>将关注节点父节点b颜色设置为黑色</p>
</li>
<li><p>节点a中去掉一个黑色，节点a就变成了单纯的红色或者黑色</p>
</li>
<li><p>节点a的叔叔节点e颜色设置为黑色</p>
</li>
<li><p>调整结束</p>
<p><img src="https://static001.geekbang.org/resource/image/5f/44/5f73f61bf77a7f2bb75f168cf432ec44.jpg" alt="CASE4"></p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://everyseptember.github.io/2019/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A1%A8-%E7%BA%A2%E9%BB%91%E6%A0%91/" data-id="ckp7o8tjn001n10mw57suc3yq" data-title="数据结构-非线性表-红黑树" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A0%91/" rel="tag">树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/" rel="tag">红黑树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A1%A8/" rel="tag">非线性表</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-数据结构-非线性表-二叉树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A1%A8-%E4%BA%8C%E5%8F%89%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2019-04-08T11:25:08.000Z" itemprop="datePublished">2019-04-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A1%A8-%E4%BA%8C%E5%8F%89%E6%A0%91/">数据结构-非线性表-二叉树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>没有父节点的节点叫做<strong>根节点</strong>，没有子节点的节点叫做<strong>叶子结点</strong>，同一个父节点下的节点互为<strong>兄弟节点</strong>。</p>
<ul>
<li>高度（Height）：节点到叶子结点的<strong>最长路径（边数）</strong></li>
<li>深度（Depth）：根节点到这个节点所经历的<strong>路径（边数）</strong></li>
<li>层（Level）：节点的深度+1</li>
<li>树的高度：根节点的高度</li>
</ul>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>二叉树每个节点最多有两个子节点。</p>
<ul>
<li><strong>满二叉树</strong>：叶子结点全都在最底层，除了叶子结点外，每个节点都有左右两个子节点</li>
<li><strong>完全二叉树</strong>：叶子结点都在最底下两层，最后一层的叶子节点靠左排列，并且除了最后一层，其他层的节点个数都要达到最大</li>
</ul>
<p>如下图中，1为普通二叉树，2为满二叉树，3为完全二叉树</p>
<p><img src="https://static001.geekbang.org/resource/image/09/2b/09c2972d56eb0cf67e727deda0e9412b.jpg" alt="二叉树"></p>
<h2 id="表示（存储）二叉树"><a href="#表示（存储）二叉树" class="headerlink" title="表示（存储）二叉树"></a>表示（存储）二叉树</h2><h3 id="链式存储法"><a href="#链式存储法" class="headerlink" title="链式存储法"></a>链式存储法</h3><p>每个节点有三个字段，一个用来存储数据，另外两个用来存储子节点的位置</p>
<p><img src="https://static001.geekbang.org/resource/image/12/8e/12cd11b2432ed7c4dfc9a2053cb70b8e.jpg" alt="链式存储法"></p>
<h3 id="顺序存储法"><a href="#顺序存储法" class="headerlink" title="顺序存储法"></a>顺序存储法</h3><p>顺序存储法基于数组实现，将根节点存储在<code>i=1</code>的位置，左子节点存储在<code>2*i</code>的位置，右子节点存储在<code>2*i+1</code>的位置。i表示父节点的位置。</p>
<p><img src="https://static001.geekbang.org/resource/image/14/30/14eaa820cb89a17a7303e8847a412330.jpg" alt="顺序存储法"></p>
<p>对于顺序存储法而言，满二叉树和完全二叉树除了0位置是没有空元素的。所以要求完全二叉树的最后一层的叶子结点全靠左。</p>
<h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><ul>
<li><strong>前序遍历</strong>：指先遍历该节点，然后是左子节点，然后是右子节点</li>
<li><strong>中序遍历</strong>：指先遍历左子节点，然后是该节点，然后是右子节点<ul>
<li>前驱节点与后继节点：在二叉树中的前驱节点与后继节点的定义是指二叉树在中序遍历时，其上一节点与下一节点</li>
</ul>
</li>
<li><strong>后序遍历</strong>：指先遍历该节点，然后是右子节点，然后是左子节点</li>
</ul>
<p>实际上，二叉树的前中后序遍历就是一个递归的过程</p>
<p>一个简易的顺序二叉树前序遍历过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] tree;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        length = tree.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span> <span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(tree[i]);</span><br><span class="line">        traverse(<span class="number">2</span> * i);</span><br><span class="line">        traverse(<span class="number">2</span> * i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        traverse(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> BinaryTree().print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>二叉查找树在树的任意一个节点，其左子树中的每个节点的值都要小于这个节点的值，而右子树节点的值都要大于这个节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> binary;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node tree;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">private</span> Node left;</span><br><span class="line">        <span class="keyword">private</span> Node right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">recursiveFind</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tree.data == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> tree;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; tree.data &amp;&amp; tree.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> recursiveFind(target);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; tree.data &amp;&amp; tree.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> recursiveFind(target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">find</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Node node = tree;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; node.data) &#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; node.data) &#123;</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">insert</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(target);</span><br><span class="line">        Node node = tree = tree == <span class="keyword">null</span> ? newNode : tree;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.data == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.data &gt; target) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    node = node.left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node.left = newNode;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    node = node.right;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node.right = newNode;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        print(tree);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            print(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            print(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(node.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Node node = tree;</span><br><span class="line">        Node parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span> &amp;&amp; node.data != target) &#123;</span><br><span class="line">            parent = node;</span><br><span class="line">            <span class="keyword">if</span> (node.data &gt; target) &#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span> &amp;&amp; node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 寻找大于目标值的最小节点</span></span><br><span class="line">            Node min = node.right;</span><br><span class="line">            Node minParent = node;</span><br><span class="line">            <span class="keyword">while</span> (min.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                minParent = min;</span><br><span class="line">                min = min.left;</span><br><span class="line">            &#125;</span><br><span class="line">            node.data = min.data;</span><br><span class="line">            node = min;</span><br><span class="line">            parent = minParent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node child = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            child = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            child = node.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根节点</span></span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            tree = child;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.left == node) &#123;</span><br><span class="line">            parent.left = child;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent.right = child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找最小节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">findMinValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tree == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node node = tree;</span><br><span class="line">        <span class="keyword">while</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找最大节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">findMaxValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tree == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node node = tree;</span><br><span class="line">        <span class="keyword">while</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="支持重复数据的二叉查找树"><a href="#支持重复数据的二叉查找树" class="headerlink" title="支持重复数据的二叉查找树"></a>支持重复数据的二叉查找树</h2><ul>
<li>使用链表等实现单节点存储多个数据</li>
<li>使用右子树存储重复数据<ul>
<li>新增：在遇到相同值的节点时，将新值插入到目标值的右子树中，在右子树找到大于等于目标值的最小节点，然后插入新节点</li>
<li>查找：使用普通查找方法，找到目标值后仍继续查找，直到查找到叶子节点</li>
<li>删除：使用查找方法依次找到每个节点然后删除</li>
</ul>
</li>
</ul>
<h2 id="二叉查找树的时间复杂度"><a href="#二叉查找树的时间复杂度" class="headerlink" title="二叉查找树的时间复杂度"></a>二叉查找树的时间复杂度</h2><ul>
<li>最差情况下，左右子树极不平衡，退化成链表，其时间复杂度为O(n)</li>
<li>最好情况下，满二叉树或完全二叉树，时间复杂度与高度成正比，即O(height)；<ul>
<li>借助等比求和，完全二叉树的层数在<code>[log2(n+1), log2n +1]</code>之间，即其时间复杂度为O(logn)</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://everyseptember.github.io/2019/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A1%A8-%E4%BA%8C%E5%8F%89%E6%A0%91/" data-id="ckp7o8tjj001h10mw9i3y5pre" data-title="数据结构-非线性表-二叉树" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A0%91/" rel="tag">树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A1%A8/" rel="tag">非线性表</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Freemarker/" rel="tag">Freemarker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">Java多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/" rel="tag">Java核心技术</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatis/" rel="tag">MyBatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL%E5%9F%BA%E7%A1%80/" rel="tag">MySQL基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" rel="tag">MySQL存储引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSM/" rel="tag">SSM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-MVC/" rel="tag">Spring MVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Web/" rel="tag">Spring Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Springboot%E7%AC%94%E8%AE%B0/" rel="tag">Springboot笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Springboot%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B0/" rel="tag">Springboot零散笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" rel="tag">二分查找</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" rel="tag">分库分表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/" rel="tag">参数配置</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%93%88%E5%B8%8C/" rel="tag">哈希</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE/" rel="tag">图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="tag">基础知识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A0%86/" rel="tag">堆</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/" rel="tag">字符串匹配</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/" rel="tag">开发模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%85%A2SQL%E6%97%A5%E5%BF%97/" rel="tag">慢SQL日志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/" rel="tag">执行计划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%A3%E5%88%97%E8%A1%A8/" rel="tag">散列表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9E%B6%E6%9E%84/" rel="tag">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91/" rel="tag">树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/" rel="tag">红黑树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/" rel="tag">线性表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%90%E7%BB%B4/" rel="tag">运维</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A1%A8/" rel="tag">非线性表</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Freemarker/" style="font-size: 10px;">Freemarker</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 10px;">Java多线程</a> <a href="/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/" style="font-size: 11.67px;">Java核心技术</a> <a href="/tags/MyBatis/" style="font-size: 10px;">MyBatis</a> <a href="/tags/MySQL/" style="font-size: 18.33px;">MySQL</a> <a href="/tags/MySQL%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">MySQL基础</a> <a href="/tags/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" style="font-size: 10px;">MySQL存储引擎</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/SSM/" style="font-size: 16.67px;">SSM</a> <a href="/tags/Spring/" style="font-size: 11.67px;">Spring</a> <a href="/tags/Spring-MVC/" style="font-size: 11.67px;">Spring MVC</a> <a href="/tags/Spring-Web/" style="font-size: 10px;">Spring Web</a> <a href="/tags/Springboot%E7%AC%94%E8%AE%B0/" style="font-size: 10px;">Springboot笔记</a> <a href="/tags/Springboot%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B0/" style="font-size: 20px;">Springboot零散笔记</a> <a href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" style="font-size: 10px;">二分查找</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 13.33px;">二叉树</a> <a href="/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" style="font-size: 10px;">分库分表</a> <a href="/tags/%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/" style="font-size: 10px;">参数配置</a> <a href="/tags/%E5%93%88%E5%B8%8C/" style="font-size: 10px;">哈希</a> <a href="/tags/%E5%9B%BE/" style="font-size: 10px;">图</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 10px;">基础知识</a> <a href="/tags/%E5%A0%86/" style="font-size: 10px;">堆</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/" style="font-size: 10px;">字符串匹配</a> <a href="/tags/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">开发模式</a> <a href="/tags/%E6%85%A2SQL%E6%97%A5%E5%BF%97/" style="font-size: 10px;">慢SQL日志</a> <a href="/tags/%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/" style="font-size: 10px;">执行计划</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">排序</a> <a href="/tags/%E6%95%A3%E5%88%97%E8%A1%A8/" style="font-size: 10px;">散列表</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 20px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 18.33px;">数据结构</a> <a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 13.33px;">架构</a> <a href="/tags/%E6%A0%91/" style="font-size: 13.33px;">树</a> <a href="/tags/%E6%A1%86%E6%9E%B6/" style="font-size: 16.67px;">框架</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a> <a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 10px;">索引</a> <a href="/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/" style="font-size: 10px;">红黑树</a> <a href="/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/" style="font-size: 10px;">线性表</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a> <a href="/tags/%E8%BF%90%E7%BB%B4/" style="font-size: 11.67px;">运维</a> <a href="/tags/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A1%A8/" style="font-size: 15px;">非线性表</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/28/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2021/05/19/CAP/">CAP</a>
          </li>
        
          <li>
            <a href="/2020/06/09/%E6%9E%B6%E6%9E%84-Spring%20Web%E4%B8%8ESpring%20MVC/">架构-Spring Web与Spring MVC</a>
          </li>
        
          <li>
            <a href="/2020/06/09/%E6%9E%B6%E6%9E%84-Spring/">架构-Spring</a>
          </li>
        
          <li>
            <a href="/2020/06/08/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/">架构-Java基础</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 lu<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>