<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="lu"><title>数据结构-线性表 · 这里是lu</title><meta name="description" content="线性表就是数据排成一条线一样的结构，每个线性表上的数据最多只有前后两个方向。
数组数组具有连续的内存空间和相同类型的数据。
数组的随机访问以int[] a = new int[10]为例，当数组在初始化的时候，实际上申请了一块10个int长度的连续内存空间。
此时，只需要记住数组的首地址就可以了，当"><meta name="keywords" content="lu的博客"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">这里是lu</a></h3><div class="description"><p>心之所愿，无事不成。<br> Nothing is impossible to a willing heart.</p></div></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/EverySeptember"><i class="fa fa-github"></i></a></li></ul><div class="footer"><div class="p"> <span>©  </span><i class="fa fa-star"></i><span> lu</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><a href="https://github.com/mrcore/hexo-theme-Anatole-Core" target="_blank">Anatole-Core  </a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/tags">标签</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>数据结构-线性表</a></h3></div><div class="post-content"><p>线性表就是数据排成一条线一样的结构，每个线性表上的数据最多只有前后两个方向。</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组具有连续的内存空间和相同类型的数据。</p>
<h2 id="数组的随机访问"><a href="#数组的随机访问" class="headerlink" title="数组的随机访问"></a>数组的随机访问</h2><p>以<code>int[] a = new int[10]</code>为例，当数组在初始化的时候，实际上申请了一块10个int长度的连续内存空间。</p>
<p>此时，只需要记住数组的首地址就可以了，当需要访问数组中某一元素的数据，计算<code>首地址 + k * 数据长度</code>便可以得到目标数据的地址。</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>数组进行插入操作时，需要将目标位置及之后的所有数据都后移一位。</p>
<p>当插入位置在末位时，无须移动数据，其最好时间复杂度为<code>O(1)</code>；当插入位置在首位时，需要移动所有数据，其最坏时间复杂度为<code>O(n)</code>；以此计算平均时间复杂度<code>(1 + 2 + 3 + ... + n) / n</code>，即<code>O(n)</code>。</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除操作与插入操作复杂度相同，但可以采用假删除的方式来减少移动数据的次数。</p>
<p>在数组执行删除操作时，可以先将删除的数据记录下来，而不是真正删除数据；当数组空间不足时，再将数据真正删除，并移动其他数据。这一思想与JVM的GC操作十分相似。</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>容器类封装了许多操作，可以使操作更加简易，且支持动态扩容。但其本质仍然是数组操作。</p>
<p>Java中提供的ArrayList便是一种数组的容器类。</p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表不需要连续的内容空间，它可以通过指针将不连续的内存空间串联起来。我们将一个内存空间称为<strong>节点</strong>。</p>
<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>单链表中的节点除了存储数据之外，还需要记录下一个节点的地址，把这个记录下个地址的指针叫做<strong>后继指针</strong>。在单链表中，尾节点的后继指针指向一个空地址NULL。</p>
<h3 id="插入删除"><a href="#插入删除" class="headerlink" title="插入删除"></a>插入删除</h3><p>链表的插入删除操作十分简单，由于链表内存空间不连续，所以不需要进行数据搬运；仅需更改目标位置和新插入节点的指针即可。其时间复杂度是<code>O(1)</code>。</p>
<p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g09eqqwuhej30vq0i2dhb.jpg" alt="链表插入删除操作"></p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>链表查找的性能较差，只能每个节点依次遍历进行查询。其时间复杂度是<code>O(n)</code>。</p>
<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>循环链表是一种特殊的单链表，其后继指针不是NULL，而是指向头结点。</p>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双向链表与单链表的差别在于双向链表有两个指针，除后继指针之外还有指向前一节点的<strong>前驱指针</strong>。</p>
<p>双向链表由于多出一个指针，多以它相对于单链表也更加占用空间。但同时在数据操作上也比但指针更加高效。</p>
<h3 id="插入删除-1"><a href="#插入删除-1" class="headerlink" title="插入删除"></a>插入删除</h3><ul>
<li>在进行插入删除操作时，由于单链表没有前驱指针，在指定位置进行操作时，往往需要对数据重新遍历以找到目标位置的前一节点来修改新的指针地址。</li>
</ul>
<h3 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h3><p>对有序链表，可以头尾同时查找，或者在已知某一节点的情况下，向前或向后查找，这使得查询速度优于单链表。</p>
<h2 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h2><p>理同循环链表。</p>
<h2 id="哨兵节点（头结点）"><a href="#哨兵节点（头结点）" class="headerlink" title="哨兵节点（头结点）"></a>哨兵节点（头结点）</h2><p>对于空链表，在插入或删除操作时就需要对节点进行特殊判断。引入一个值永远为空的哨兵节点可以使代码更加一致。</p>
<p>哨兵节点是链表一直都存在的附加节点，它是链表真正的第一节点，它一直存在且不存储任何内容。</p>
<h1 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h1><p>跳表是一种<strong>动态数据结构</strong>。使用另外几条链表建立<strong>索引层</strong>，即将原链表每几个数据提取建立新的链表，变减少了节点的数量，在本层索引找到两个节点之间的位置便可以进入下一层继续寻找。</p>
<p><img src="https://ws3.sinaimg.cn/large/005BYqpgly1g0l8rvargyj30vq0ifjtf.jpg" alt="跳表"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul>
<li>插入新数据时随机确定新数据的最高层级数</li>
<li>插入数据时找到小于目标值的最大节点，并将该节点属性赋给新节点，然后该节点指向新节点</li>
<li>查找数据时从该表的最高层级开始向下循环</li>
<li>删除数据时使用0层级判断，但需要断开该节点所有层级的连接</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跳表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SkipList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_LEVEL = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> levelCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">find</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node p = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = levelCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p.forwards[i] != <span class="keyword">null</span> &amp;&amp; p.forwards[i].data &lt; value) &#123;</span><br><span class="line">                p = p.forwards[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.forwards[<span class="number">0</span>] != <span class="keyword">null</span> &amp;&amp; p.forwards[<span class="number">0</span>].data == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> p.forwards[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> level = randomLevel();</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node();</span><br><span class="line">        newNode.data = value;</span><br><span class="line">        newNode.maxLevel = level;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新节点组成的纵向数组</span></span><br><span class="line">        Node[] update = <span class="keyword">new</span> Node[level];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level; ++i) &#123;</span><br><span class="line">            update[i] = head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node p = head;</span><br><span class="line">        <span class="comment">// 由不同层级依次由上向下循环遍历数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="comment">// 寻找当前层级上可以预见的小于目标值的最大节点</span></span><br><span class="line">            <span class="keyword">while</span> (p.forwards[i] != <span class="keyword">null</span> &amp;&amp; p.forwards[i].data &lt; value) &#123;</span><br><span class="line">                p = p.forwards[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将找到的目标节点赋值给新节点数组</span></span><br><span class="line">            update[i] = p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level; ++i) &#123;</span><br><span class="line">            <span class="comment">// 将较小的旧节点属性赋值给新节点</span></span><br><span class="line">            newNode.forwards[i] = update[i].forwards[i];</span><br><span class="line">            <span class="comment">// 将新节点作为属性赋值给较小的旧节点</span></span><br><span class="line">            update[i].forwards[i] = newNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (levelCount &lt; level) &#123;</span><br><span class="line">            levelCount = level;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node[] update = <span class="keyword">new</span> Node[levelCount];</span><br><span class="line">        Node p = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = levelCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p.forwards[i] != <span class="keyword">null</span> &amp;&amp; p.forwards[i].data &lt; value) &#123;</span><br><span class="line">                p = p.forwards[i];</span><br><span class="line">            &#125;</span><br><span class="line">            update[i] = p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.forwards[<span class="number">0</span>] != <span class="keyword">null</span> &amp;&amp; p.forwards[<span class="number">0</span>].data == value) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = levelCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (update[i].forwards[i] != <span class="keyword">null</span> &amp;&amp; update[i].forwards[i].data == value) &#123;</span><br><span class="line">                    update[i].forwards[i] = update[i].forwards[i].forwards[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取随机层数</span></span><br><span class="line"><span class="comment">     * 循环的作用是防止伪随机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">randomLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAX_LEVEL; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (random.nextInt() % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                level++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node p = head;</span><br><span class="line">        <span class="keyword">while</span> (p.forwards[<span class="number">0</span>] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(p.forwards[<span class="number">0</span>] + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            p = p.forwards[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> data = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> maxLevel = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 该节点在所有maxLevel层级及以下可见节点组成的数组</span></span><br><span class="line">        <span class="keyword">private</span> Node[] forwards = <span class="keyword">new</span> Node[MAX_LEVEL];</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;data=&quot;</span> + data +</span><br><span class="line">                    <span class="string">&quot;, maxLevel=&quot;</span> + maxLevel +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>后进先出，先进后出，这就是典型的“栈”结构。栈是一种操作受限的线性表，只允许在一段插入和删除数据。</p>
<p>用数组实现的栈叫做<strong>顺序栈</strong>，用链表实现的栈叫做<strong>链式栈</strong>。</p>
<h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用数组实现的顺序栈</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-2-17 17:21:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String[] items;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栈大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栈中现有元素数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化栈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 栈的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.items = <span class="keyword">new</span> String[n];</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入栈操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 入栈数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否入栈成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">push</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果栈已满，则入栈失败</span></span><br><span class="line">        <span class="keyword">if</span> (count == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 动态扩容（并不常用）</span></span><br><span class="line">        <span class="comment">/*if (count == n) &#123;</span></span><br><span class="line"><span class="comment">            String[] temp = new String[n * 2];</span></span><br><span class="line"><span class="comment">            System.arraycopy(items, 0, temp, 0, n);</span></span><br><span class="line"><span class="comment">            n *= 2;</span></span><br><span class="line"><span class="comment">            this.items = temp;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="comment">// 将数据放到当前栈的位置</span></span><br><span class="line">        items[count++] = item;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果栈为空，返回null</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回count - 1的元素</span></span><br><span class="line">        String temp = items[count-- - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><ul>
<li><p>函数调用栈</p>
</li>
<li><p>表达式求值</p>
<p>表达式求值是利用两个栈分别存储数字和运算符，当有数字则直接压入数字栈，有运算符则受限与当前栈顶运算符进行比较：如果优先级高于当前栈顶运算符则压入运算符栈，否则取当前数字栈顶的两个数字和运算符栈顶的运算符进行计算，并将计算结果压入数字栈，并继续进行运算符比较。</p>
<p><img src="https://ws3.sinaimg.cn/large/005BYqpgly1g0asoawbevj30vq0lywgv.jpg" alt="栈实现表达式求值"></p>
</li>
<li><p>成对符号匹配</p>
</li>
</ul>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>先进先出，就是一种典型的队列结构。队列跟栈一样，也是一种操作受限的线性表数据结构。</p>
<p>与栈同理，用数组实现的队列叫做<strong>顺序队列</strong>，用链表实现的队列叫做<strong>链式队列</strong>。</p>
<h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 循环队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-2-18 19:40:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 数组 */</span></span><br><span class="line">    <span class="keyword">private</span> String[] items;</span><br><span class="line">    <span class="comment">/** 队列长度 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">/** 队首下标 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** 队尾下标 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** 已有元素长度 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.items = <span class="keyword">new</span> String[n];</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入队操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 入队元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否入队成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断空间是否充足</span></span><br><span class="line">        <span class="keyword">if</span> (head == tail &amp;&amp; count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        items[tail++] = item;</span><br><span class="line">        <span class="keyword">if</span> (tail == n) &#123;</span><br><span class="line">            tail = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 元素计数+1</span></span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出队操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 出队元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断当前是否是空队列</span></span><br><span class="line">        <span class="keyword">if</span> (head == tail &amp;&amp; count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 出队</span></span><br><span class="line">        String temp = items[head++];</span><br><span class="line">        <span class="keyword">if</span> (head == n) &#123;</span><br><span class="line">            head = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 元素计数-1</span></span><br><span class="line">        --count;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用空元素实现的循环队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-2-18 19:40:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue2</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 数组 */</span></span><br><span class="line">    <span class="keyword">private</span> String[] items;</span><br><span class="line">    <span class="comment">/** 队列长度 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">/** 队首下标 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** 队尾下标 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.items = <span class="keyword">new</span> String[n];</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入队操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 入队元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否入队成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断空间是否充足</span></span><br><span class="line">        <span class="keyword">if</span> ((tail + <span class="number">1</span>) % n == head) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        items[tail] = item;</span><br><span class="line">        tail = (tail + <span class="number">1</span>) % n;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出队操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 出队元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断当前是否是空队列</span></span><br><span class="line">        <span class="keyword">if</span> (head == tail) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 出队</span></span><br><span class="line">        String temp = items[head];</span><br><span class="line">        head = (head + <span class="number">1</span>) % n;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>在队列基础上加上阻塞操作：在队列为空的时候，阻塞出队操作；在队列已满的时候，阻塞入队操作。</p>
<h2 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h2><p>线程安全的队列叫做并发队列。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-02-16</span><i class="fa fa-tag"></i><a class="tag" href="/tags/数据结构/" title="数据结构">数据结构 </a><a class="tag" href="/tags/线性表/" title="线性表">线性表 </a><span class="leancloud_visitors"></span></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2019/02/25/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" title="算法-二分查找">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2019/01/26/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/" title="算法-排序">下一篇</a></li></ul></div><script src="/js/visitors.js"></script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/baidu-tongji.js"></script></body></html>